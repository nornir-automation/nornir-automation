<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on nornir.tech</title>
        <link>/posts/</link>
        <description>Recent content in Posts on nornir.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Nornir</copyright>
        <lastBuildDate>Fri, 06 Aug 2021 00:00:00 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Testing your network with Nornir TestsProcessor</title>
            <link>/2021/08/06/testing-your-network-with-nornir-testsprocessor/</link>
            <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
            
            <guid>/2021/08/06/testing-your-network-with-nornir-testsprocessor/</guid>
            <description>This is a guest post by Denis Mulyalin, follow github account and twitter feed for latest updates.
 Network testing overview For the start lets introduce some terminology and structure. Network Testing could be roughly defined as a process of making sure that your network is adhere to a certain level of quality. Network tests itself could be classified based on a variety of properties. For example using test scope as a test metric allows us to sort tests across these categories:</description>
            <content type="html"><![CDATA[<p><em>This is a guest post by Denis Mulyalin, follow <a href="https://github.com/dmulyalin">github account</a> and <a href="https://twitter.com/DMulyalin">twitter feed</a> for latest updates.</em></p>
<hr>
<h1 id="network-testing-overview">Network testing overview</h1>
<p>For the start lets introduce some terminology and structure. <strong>Network Testing</strong>
could be roughly defined as a process of making sure that your network is adhere
to a certain level of quality. Network tests itself could be classified based on
a variety of properties. For example using <strong>test scope</strong> as a test metric allows
us to sort tests across these categories:</p>
<ul>
<li>local (unit) - verify functionality and features contained within device itself
e.g. platform state, software version, configuration</li>
<li>adjacent (integration) - verify operation between device pairs e.g. various
protocols peerings, links, point to point connectivity</li>
<li>network (system) - verify network function end to end e.g. end-to-end
connectivity and performance verification</li>
</ul>
<p>Another criteria which is not the very apparent but quiet important from automation
perspectives is <strong>test complexity</strong> which identifies how difficult is it to automate
it. Using complexity we can separate tests across these sets:</p>
<ul>
<li>low complexity - easy to automate e.g. check that show command output contains
particular pattern</li>
<li>moderate complexity - requires correlation and testing of several criteria e.g.
verify that all active ISIS enabled interfaces have certain MTU</li>
<li>high complexity - usually this type of tests represent a collection of sub tests
spread across time and domains e.g. verify customer service provisioning</li>
</ul>
<p>In author&rsquo;s experience, about 70% of networking tests fall in the <em>low complexity</em>
category, 20% of tests are of <em>moderate complexity</em> and <em>high complexity</em> tests account
for around 9% of cases, 1% remaining probably cases that cannot be automated at all.
These numbers of course can differ from environment to environment and only serve
demonstration purposes to give us an idea of what are we dealing with.</p>
<h1 id="network-testing-tools-landscape">Network Testing tools landscape</h1>
<p>If majority of tests are of low complexity to automate, why not we all already
running automated tests suits on a constant basis?</p>
<p>Probably complexity itself is the answer here, complexity is a very subjective
criteria, it defines the entry barrier and if it too big, people just skip it
falling back to traditional methods.</p>
<p>Nonetheless, some network testing frameworks/tools that Author aware of are:</p>
<ul>
<li>PyATS - Ecosystem of libraries and tools to set up and run automated network tests</li>
<li>Napalm Validate - NAPALM built-in function to validate getters output</li>
<li>Batfish - Network Configuration Analysis tool</li>
</ul>
<p>List is not exhaustive, quiet sure other open source or free tools exist that Author
did not came across yet.</p>
<p>Another framework that we ca use for testing in general and network testing in
particular is - <em>Python Programming Language</em>.</p>
<p>We can either use Python itself or testing libraries that are part of Python ecosystem
such as <a href="https://docs.pytest.org/">pytest</a> or <a href="https://robotframework.org/">robot</a>.</p>
<p>For instance, if we decide to use Pytest we can write something like:</p>
<pre><code>from nornir import InitNornir
from nornir_netmiko import netmiko_send_command

nr = InitNornir(config_file=&quot;nornir_config.yaml&quot;)

def test_software_version():
    results = nr.run(
        task=netmiko_send_command,
        command_string=&quot;show version&quot;,
    )
    for host, result in results.items():
        assert &quot;16.10.1&quot; in result[0].result, &quot;{} software version is wrong&quot;.format(host)

def test_syslog_config():
    results = nr.run(
        task=netmiko_send_command,
        command_string=&quot;show run | inc logging&quot;,
    )
    for host, result in results.items():
        assert &quot;10.0.0.1&quot; in result[0].result, &quot;{} logging configuration is wrong&quot;.format(host)
</code></pre><p>Save above code in a file named <code>test_network_suite_v1.py</code> and provided that we have
Nornir, Netmiko and Pytest installed and configured we can run above tests:</p>
<pre><code>pytest test_network_suite_v1.py -vv
</code></pre><p>If all good we should get output similar to this:</p>
<pre><code>collected 2 items

test_network_suite_v1.py::test_software_version PASSED   [ 50%]
test_network_suite_v1.py::test_syslog_config PASSED      [100%]

============== 2 passed, 0 warnings in 4.35s ==================
</code></pre><p>What remaining is &ldquo;just&rdquo; to re-factor the code to account for individual devices,
make script to emit testing results in some pretty format and write another 10
or 100 test functions to have a satisfying test coverage.</p>
<p>Main benefit of that approach is that it gives the <em>ultimate flexibility</em> and
control - things you can test only limited by your knowledge of Python Programming
Language and its ecosystem of networking tools. It probably would be true to say
that you can test virtually anything using that approach.</p>
<p>Main drawback - learning curve or entry barrier. To gain the power of ultimate
flexibility one need to spend significant time and efforts to train itself.</p>
<p>Also, another drawback, we need to write code, potentially quiet a lot of code to
test even for something as simple as checking show commands output for pattern
containment.</p>
<p>Most of that code would end up redundant and could be organized in various functions
for better re-usability and DRY (don&rsquo;t repeat yourself) principles. But, as it
usually happens, that already was done and in this case distributed in a form of
Nornir <code>TestsProcessor</code> plugin within <a href="https://nornir-salt.readthedocs.io/">nornir-salt</a>
package.</p>
<h1 id="nornir-testsprocessor">Nornir TestsProcessor</h1>
<p>Nornir <a href="https://nornir.readthedocs.io/en/latest/tutorial/processors.html">processors</a>
are plugins that tap into task execution process to do various actions such as log
events, work with results or do other processing.</p>
<p>Nornir-salt is a package that contains Nornir plugins and functions including
<code>TestsProcessor</code>. Nornir-salt developed as part of SALTSTACK Nornir Proxy-Minion.
But, all plugins in Nornir-salt package designed to work with Nornir directly
and does not have any SALTSTACK dependencies.</p>
<p>Sample code to run tests using <code>TestsProcessor</code> - save to <code>test_network_suite_v2.py</code> file:</p>
<pre><code>from nornir import InitNornir
from nornir_salt import TestsProcessor, TabulateFormatter, netmiko_send_commands

nr = InitNornir(config_file=&quot;nornir_config.yaml&quot;)

# define your tests suite
tests_suite = [
    [&quot;show version&quot;, &quot;contains&quot;, &quot;17.3.1&quot;, &quot;Software version test&quot;],
    [&quot;show run | inc logging&quot;, &quot;contains&quot;, &quot;10.0.0.1&quot;, &quot;Logging configuration check&quot;],
    [&quot;show interfaces&quot;, &quot;!contains_lines&quot;, [&quot;Half Duplex&quot;, &quot;10Mbps&quot;], &quot;Duplex and speed test&quot;]
]

# add tests processor
nr_with_tests = nr.with_processors(
    [
        TestsProcessor(tests_suite)
    ]
)

# collect output from devices using netmiko_send_commands task plugin
results = nr_with_tests.run(
    task=netmiko_send_commands,
    commands=[
        &quot;show version&quot;,
        &quot;show run | inc logging&quot;,
        &quot;show interfaces&quot;
    ]
)

# prettify results transforming them in a text table using TabulateFormatter
table = TabulateFormatter(results, tabulate=&quot;brief&quot;)

# print results
print(table)
</code></pre><p>Running above code:</p>
<pre><code>python3 test_network_suite_v2.py
</code></pre><p>Should give us this output:</p>
<pre><code>+----+--------+-----------------------------+----------+-----------------------+
|    | host   | name                        | result   | exception             |
+====+========+=============================+==========+=======================+
|  0 | R1     | Software version test       | FAIL     | Pattern not in output |
+----+--------+-----------------------------+----------+-----------------------+
|  1 | R1     | Logging configuration check | PASS     |                       |
+----+--------+-----------------------------+----------+-----------------------+
|  2 | R1     | Duplex and speed test       | PASS     |                       |
+----+--------+-----------------------------+----------+-----------------------+
|  3 | R2     | Software version test       | FAIL     | Pattern not in output |
+----+--------+-----------------------------+----------+-----------------------+
|  4 | R2     | Logging configuration check | PASS     |                       |
+----+--------+-----------------------------+----------+-----------------------+
|  5 | R2     | Duplex and speed test       | PASS     |                       |
+----+--------+-----------------------------+----------+-----------------------+
</code></pre><p><code>TestsProcessor</code> uses tests suite to run the tests - test suite is a list of
dictionaries or a list of lists, where each dictionary or list contains tests details.</p>
<p>List of lists tests suite is more concise but only allows to define these four test parameters:</p>
<ul>
<li>first list item - mandatory, Nornir results task name</li>
<li>second list item - mandatory, test function name</li>
<li>third list item - mandatory, test criteria, pattern</li>
<li>last item - optional, test name</li>
</ul>
<p>Sample list of lists test suite with single test in it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">tests_suite <span style="color:#f92672">=</span> [
    [<span style="color:#e6db74">&#34;show version&#34;</span>, <span style="color:#e6db74">&#34;contains&#34;</span>, <span style="color:#e6db74">&#34;17.3.1&#34;</span>, <span style="color:#e6db74">&#34;Test software version&#34;</span>],
]
</code></pre></div><p>List of dictionaries is more verbose and allows to specify more options, example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">tests_suite <span style="color:#f92672">=</span> [
    {
        <span style="color:#e6db74">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Test version&#34;</span>,
        <span style="color:#e6db74">&#34;task&#34;</span>: <span style="color:#e6db74">&#34;show version&#34;</span>,
        <span style="color:#e6db74">&#34;test&#34;</span>: <span style="color:#e6db74">&#34;contains&#34;</span>,
        <span style="color:#e6db74">&#34;pattern&#34;</span>: <span style="color:#e6db74">&#34;17.3.1&#34;</span>,
        <span style="color:#e6db74">&#34;err_msg&#34;</span>: <span style="color:#e6db74">&#34;Software version is wrong&#34;</span>
    }
]
</code></pre></div><p>Test dictionary <code>task</code> key indicates name of the Nornir task, results of that task
feed into test function. <code>netmiko_send_commands</code> task plugin conveniently uses command
string as a name for the sub-tasks, making it easy to identify results by command itself.</p>
<p><code>TestsProcessor</code> significantly simplifies running tests for containment or
equality checks using these test functions:</p>
<ul>
<li><code>contains</code> - tests if result contains pattern</li>
<li><code>!contains</code> or <code>ncontains</code> - tests if result does not contain pattern</li>
<li><code>contains_lines</code> - tests if result contains any of the patterns from the list</li>
<li><code>!contains_lines</code> or <code>contains_lines</code> - tests if result does not contain any of the patterns</li>
<li><code>contains_re</code> - tests if result contains regular expression pattern</li>
<li><code>!contains_re</code> or <code>ncontains_re</code> - tests if result does not contains regular expression pattern</li>
<li><code>contains_lines_re</code> - tests if result contains any of the regex patterns from the list</li>
<li><code>!contains_lines_re</code> or <code>ncontains_lines_re</code> - tests if result does not contain any of regex patterns</li>
<li><code>equal</code> - checks that results are equal to provided value</li>
<li><code>!equal</code> or <code>nequal</code> - checks that results are not equal to provided value</li>
</ul>
<p>Containment or equality checks are very similar to how we, Humans, verify output
from devices:</p>
<ol>
<li>Run show command</li>
<li>Check if output contains certain values</li>
<li>Decide if test failed or succeeded</li>
</ol>
<p>Containment test functions do exactly that but in an automated fashion using
output collected from devices by Nornir.</p>
<p>With above test functions we already can test significant set of use cases:</p>
<ul>
<li>device configuration content verification</li>
<li>single show commands output checks</li>
<li>verify ping command results</li>
</ul>
<p>To make up for more &ldquo;production&rdquo; ready example lets use simple trick - move definition of
our tests suite in a <code>tests_suite.yaml</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#66d9ef">name</span>: Software version test
  <span style="color:#66d9ef">task</span>: show version
  <span style="color:#66d9ef">test</span>: contains
  <span style="color:#66d9ef">pattern</span>: <span style="color:#e6db74">&#34;17.3.1&#34;</span>
  <span style="color:#66d9ef">err_msg</span>: Software version is wrong
  
- <span style="color:#66d9ef">name</span>: Logging configuration check
  <span style="color:#66d9ef">task</span>: <span style="color:#e6db74">&#34;show run | inc logging&#34;</span>
  <span style="color:#66d9ef">test</span>: contains
  <span style="color:#66d9ef">pattern</span>: <span style="color:#ae81ff">10.0.0.1</span>
  <span style="color:#66d9ef">err_msg</span>: Logging configuration is wrong
  
- <span style="color:#66d9ef">name</span>: Duplex and speed test
  <span style="color:#66d9ef">task</span>: <span style="color:#e6db74">&#34;show interfaces&#34;</span>
  <span style="color:#66d9ef">test</span>: <span style="color:#e6db74">&#34;!contains_lines&#34;</span>
  <span style="color:#66d9ef">pattern</span>: 
    - Half Duplex
    - 10Mbps
  <span style="color:#66d9ef">err_msg</span>: Logging configuration is wrong
</code></pre></div><p>Update <code>test_network_suite_v2.py</code> code and save it in <code>test_network_suite_v3.py</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> yaml
<span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir_salt <span style="color:#f92672">import</span> TestsProcessor, TabulateFormatter, netmiko_send_commands

nr <span style="color:#f92672">=</span> InitNornir(config_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;nornir_config.yaml&#34;</span>)

<span style="color:#75715e"># read tests suite</span>
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;tests_suite.yaml&#34;</span>) <span style="color:#66d9ef">as</span> f:
    tests_suite <span style="color:#f92672">=</span> yaml<span style="color:#f92672">.</span>safe_load(f<span style="color:#f92672">.</span>read())

<span style="color:#75715e"># add tests processor</span>
nr_with_tests <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>with_processors(
    [
        TestsProcessor(tests_suite)
    ]
)

<span style="color:#75715e"># collect commands to get from devices accounting </span>
<span style="color:#75715e"># for case when task is a list of commands</span>
commands <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> tests_suite:
    <span style="color:#66d9ef">if</span> isinstance(item[<span style="color:#e6db74">&#34;task&#34;</span>], str):
        commands<span style="color:#f92672">.</span>append(item[<span style="color:#e6db74">&#34;task&#34;</span>])
    <span style="color:#66d9ef">elif</span> isinstance(item[<span style="color:#e6db74">&#34;task&#34;</span>], list):    
        commands<span style="color:#f92672">.</span>extend(item[<span style="color:#e6db74">&#34;task&#34;</span>])
        
<span style="color:#75715e"># collect output from devices using netmiko_send_commands task plugin</span>
results <span style="color:#f92672">=</span> nr_with_tests<span style="color:#f92672">.</span>run(
    task<span style="color:#f92672">=</span>netmiko_send_commands,
    commands<span style="color:#f92672">=</span>commands
)

<span style="color:#75715e"># prettify results transforming them in a text table using TabulateFormatter</span>
table <span style="color:#f92672">=</span> TabulateFormatter(results, tabulate<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;brief&#34;</span>)

<span style="color:#75715e"># print results</span>
<span style="color:#66d9ef">print</span>(table)
</code></pre></div><p>Execute above code:</p>
<pre><code>python3 test_network_suite_v3.py
</code></pre><p>If all good we should see same output as before but this time tests
suite sourced from YAML file.</p>
<p>Abstracting tests suite in a YAML document makes it easy to add or remove tests.</p>
<p>For instance, what if requirements comes in to verify CRC errors counter is below
1000 on all device&rsquo;s interfaces, we can append this test to <code>tests_suite.yaml</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">
- <span style="color:#66d9ef">name</span>: Test interfaces CRC count
  <span style="color:#66d9ef">task</span>: <span style="color:#e6db74">&#34;show interfaces | inc CRC&#34;</span>
  <span style="color:#66d9ef">test</span>: <span style="color:#e6db74">&#34;!contains_re&#34;</span>
  <span style="color:#66d9ef">pattern</span>: <span style="color:#e6db74">&#34;\\d{4,} CRC&#34;</span>
  <span style="color:#66d9ef">err_msg</span>: Interfaces CRC errors above <span style="color:#ae81ff">999</span>
</code></pre></div><p>Regex pattern <code>\\d{4,} CRC</code> will match any 4 digit numbers and above, if such matches
found in output we can be positive that CRC errors are above 999 at least on one of
the interfaces.</p>
<p>Running same <code>python3 test_network_suite_v3.py</code> now gives these results:</p>
<pre><code>+----+--------+-----------------------------+----------+---------------------------+
|    | host   | name                        | result   | exception                 |
+====+========+=============================+==========+===========================+
|  0 | R1     | Software version test       | FAIL     | Software version is wrong |
+----+--------+-----------------------------+----------+---------------------------+
|  1 | R1     | Logging configuration check | PASS     |                           |
+----+--------+-----------------------------+----------+---------------------------+
|  2 | R1     | Duplex and speed test       | PASS     |                           |
+----+--------+-----------------------------+----------+---------------------------+
|  3 | R1     | Test interfaces CRC count   | PASS     |                           |
+----+--------+-----------------------------+----------+---------------------------+
|  4 | R2     | Software version test       | FAIL     | Software version is wrong |
+----+--------+-----------------------------+----------+---------------------------+
|  5 | R2     | Logging configuration check | PASS     |                           |
+----+--------+-----------------------------+----------+---------------------------+
|  6 | R2     | Duplex and speed test       | PASS     |                           |
+----+--------+-----------------------------+----------+---------------------------+
|  7 | R2     | Test interfaces CRC count   | PASS     |                           |
+----+--------+-----------------------------+----------+---------------------------+
</code></pre><p>That is it, now testing your network is as simple as adding more tests in your
<code>tests_suite.yaml</code> file.</p>
<h1 id="nornir-testsprocessor---advance-to-python">Nornir TestsProcessor - advance to Python</h1>
<p>In cases where functionality of containment and pattern matching tests is not enough
we can fall-back on Python Language capabilities. <code>TestsProcessor</code> comes with these
two test functions to help us with exactly that:</p>
<ul>
<li><code>eval</code> test function - uses Python <code>eval</code> and <code>exec</code> built-in function to evaluate
Python expression to produce test results</li>
<li><code>custom</code> test function - uses any custom-defined Python function to perform results
testing</li>
</ul>
<p><strong>Using <code>eval</code> or <code>custom</code> test functions is equivalent to running Python code directly</strong>
<strong>on your system, do not use custom test functions or test suites from untrusted/unverified</strong>
<strong>sources.</strong></p>
<p>By the set of use cases it can address <code>eval</code> probably sits in the middle between
predefined and <code>custom</code> test functions:</p>
<ol>
<li>Predefined test functions only provide pre-baked functionality, but tests easily
defined in a test suite</li>
<li>With <code>eval</code> you already can use Python Language, but limited to a single expression</li>
<li><code>custom</code> test function gives full access to Python Language but requires to write the code</li>
</ol>
<p>From the perspectives of <strong>test complexity</strong> classification we described previously,
predefined and <code>eval</code> test functions help to address low to moderate complexity test
cases while custom test function aims moderate to high complexity scenarios.</p>
<p>This is of course guidelines only, as technically all pre-defined and <code>eval</code> test
functions could be replaced with custom functions.</p>
<p>To demonstrate how to use <code>eval</code> test function lets say new requirements comes in - need to
verify that all interfaces have MTU set to 9200, for that we can append this test
case to <code>tests_suite.yaml</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">
- <span style="color:#66d9ef">name</span>: Test interfaces MTU
  <span style="color:#66d9ef">task</span>: <span style="color:#e6db74">&#34;show interfaces | inc MTU&#34;</span>
  <span style="color:#66d9ef">test</span>: <span style="color:#e6db74">&#34;eval&#34;</span>
  <span style="color:#66d9ef">expr</span>: <span style="color:#e6db74">&#34;all([&#39;9200&#39; in line for line in result.splitlines()])&#34;</span>
  <span style="color:#66d9ef">err_msg</span>: Interface MTU out of range
</code></pre></div><p>Running <code>python3 test_network_suite_v3.py</code> one more time gives these additional results:</p>
<pre><code>+----+--------+-----------------------------+----------+----------------------------+
|    | host   | name                        | result   | exception                  |
+====+========+=============================+==========+============================+
...
+----+--------+-----------------------------+----------+----------------------------+
|  4 | R1     | Test interfaces MTU         | FAIL     | Interface MTU out of range |
+----+--------+-----------------------------+----------+----------------------------+
...
+----+--------+-----------------------------+----------+----------------------------+
|  9 | R2     | Test interfaces MTU         | FAIL     | Interface MTU out of range |
+----+--------+-----------------------------+----------+----------------------------+
</code></pre><p><code>eval</code> test function injects <code>result</code> variable in global space while evaluating Python
expression, that variable contains Nornir task execution results for that particular
task or subtask.</p>
<p>One more interesting use case that <code>eval</code> can help with is processing and testing
structured data. For example, we can parse output from device using <code>textfsm</code>, <code>Genie</code>
or <code>TTP</code> parser so that task result will contain structured data that we can test
using <code>eval</code> test function.</p>
<p>However, while <code>eval</code> is quiet powerful test function it still can fall short in some
scenarios. Moreover, <code>eval</code> expressions could look rather foreign for somebody who does not
familiar with Python. In that case using <code>custom</code> test function could be a better
option.</p>
<p>Let&rsquo;s say new requirement comes in - we need to verify that dot1q tags and IP addresses
configured on device for all sub interfaces that are in UP/UP state.</p>
<p>That type of requirement usually can be addresses following this approach:</p>
<ol>
<li>Collect show commands output from devices</li>
<li>In case if task result is a text - parse it using libraries like <code>TextFSM</code>, <code>Genie</code> or <code>TTP</code></li>
<li>Process structured data further to produce test results</li>
</ol>
<p><code>custom</code> test function requires reference to testing function to feed task results into,
most straightforward way to provide that reference is by using path to a text file with
testing function content - in this case <code>test_sub_interfaces_ip.py</code> file:</p>
<pre><code>from ttp import ttp

ttp_template_intf_cfg = &quot;&quot;&quot;
interface {{ name | contains(&quot;.&quot;) }}
 ip address {{ ip }} {{ mask }}
 encapsulation dot1Q {{ dot1q }}
&quot;&quot;&quot;

ttp_template_intf_state = &quot;&quot;&quot;
&lt;group name=&quot;{{ interface }}&quot;&gt;
{{ interface | contains(&quot;.&quot;) }} is up, line protocol is up
&lt;/group&gt;
&quot;&quot;&quot;

def run(results):
    ret = []
    
    # parse show commands output
    parsed_results = {}
    for result in results:
        if result.name == &quot;show run&quot;:
            parser = ttp(data=result.result, template=ttp_template_intf_cfg)
            parser.parse()
            parsed_results[&quot;cfg&quot;] = parser.result(structure=&quot;flat_list&quot;)
        elif result.name == &quot;show interfaces | inc line protocol is up&quot;:
            parser = ttp(data=result.result, template=ttp_template_intf_state)
            parser.parse()
            parsed_results[&quot;up_interfaces&quot;] = parser.result(structure=&quot;flat_list&quot;)[0]
            
    # parsed_output structure should look like this:
    # {
    #     'cfg': [
    #         {
    #             'ip': '1.2.3.4', 
    #             'mask': '255.255.255.0', 
    #             'name': 'GigabitEthernet5.17', 
    #             'dot1q': '17'
    #         }
    #     ], 
    #     'up_interfaces': {'GigabitEthernet5.17': {}}
    # }    
    
    # process results further
    for interface in parsed_results[&quot;cfg&quot;]:
        # skip interfaces that are not up/up
        if interface[&quot;name&quot;] not in parsed_results[&quot;up_interfaces&quot;]:
            continue
        # if no dot1q tag or IP configured, it is error
        if &quot;ip&quot; not in interface or &quot;dot1q&quot; not in interface:
            ret.append(
                {
                    &quot;result&quot;: &quot;FAILED&quot;,
                    &quot;exception&quot;: &quot;{} is UP/UP but no IP or dot1q configured&quot;.format(
                        interface[&quot;name&quot;]
                    )
                }
            )
            
    return ret
</code></pre><p>Add new test to <code>tests_suite.yaml</code> file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#66d9ef">name</span>: Test sub-interfaces IP
  <span style="color:#66d9ef">task</span>: 
    - <span style="color:#e6db74">&#34;show run&#34;</span>
    - <span style="color:#e6db74">&#34;show interfaces | inc line protocol is up&#34;</span>
  <span style="color:#66d9ef">test</span>: custom
  <span style="color:#66d9ef">function_file</span>: <span style="color:#e6db74">&#34;test_sub_interfaces_ip.py&#34;</span>
</code></pre></div><p>Running our suite one more time - <code>python3 test_network_suite_v3.py</code> - gives these results:</p>
<pre><code>+----+--------+-----------------------------+----------+------------------------------------------------------------+
|    | host   | name                        | result   | exception                                                  |
+====+========+=============================+==========+============================================================+
|  0 | R1     | Software version test       | FAIL     | Software version is wrong                                  |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  1 | R1     | Logging configuration check | PASS     |                                                            |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  2 | R1     | Duplex and speed test       | PASS     |                                                            |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  3 | R1     | Test interfaces CRC count   | PASS     |                                                            |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  4 | R1     | Test sub-interfaces IP      | FAILED   | GigabitEthernet5.31 is UP/UP but no IP or dot1q configured |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  5 | R1     | Test sub-interfaces IP      | FAILED   | GigabitEthernet2.34 is UP/UP but no IP or dot1q configured |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  6 | R1     | Test sub-interfaces IP      | FAILED   | GigabitEthernet4.77 is UP/UP but no IP or dot1q configured |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  7 | R2     | Software version test       | FAIL     | Software version is wrong                                  |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  8 | R2     | Logging configuration check | PASS     |                                                            |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
|  9 | R2     | Duplex and speed test       | PASS     |                                                            |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
| 10 | R2     | Test interfaces CRC count   | PASS     |                                                            |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
| 11 | R2     | Test sub-interfaces IP      | FAILED   | GigabitEthernet6.18 is UP/UP but no IP or dot1q configured |
+----+--------+-----------------------------+----------+------------------------------------------------------------+
</code></pre><p>Ok, looks like our test suite working and we have some issues to fix.</p>
<p>Custom function file contains single function called <code>run</code> - this is the default name of the
function that <code>TestsProcessor</code> <code>custom</code> test function looks for and executes by default.</p>
<p>Custom test function should accept at least one argument with Nornir task results and
should return single dictionary or a list of dictionaries where each dictionary contains
test results.</p>
<p>In our case test definition <code>task</code> attribute contains a list of commands, because of that
<code>TestsProcessor</code> will feed a list of <code>nornir.core.task.Result</code> objects each containing output
for certain command.</p>
<h1 id="in-conclusion">In conclusion</h1>
<p>Testing is a crucial component for many processes - initial device deployment, new hardware
or software evaluation, ongoing and on failure verifications, pre/post-change tests to name
a few.</p>
<p>Be it a simple containment or pattern check, complex cross output correlation tests or structured
output evaluation - Python, Nornir and now TestsProcessor will be on your side to help
you cope with new requirements and improve the quality of your network.</p>
<blockquote>
<p>“Quality is not an act, it is a habit.”— Aristotle</p>
</blockquote>
<h1 id="reference-notes">Reference notes</h1>
<p>Code examples above reference various files, their content provided below. All <code>.yaml</code> and
<code>.py</code> files should be in same folder.</p>
<p><code>nornir_config.yaml</code> file:</p>
<pre><code>inventory:
    plugin: SimpleInventory
    options:
        host_file: &quot;hosts.yaml&quot;
        
runner:
    plugin: threaded
    options:
        num_workers: 5
</code></pre><p><code>hosts.yaml</code> file:</p>
<pre><code>R1:
  hostname: 192.168.1.10
  platform: ios
  password: nornir
  username: nornir
      
R2:
  hostname: 192.168.1.11
  platform: ios
  password: nornir
  username: nornir
</code></pre><p>Software versions Author used to run the code:</p>
<ul>
<li>Python 3.6</li>
<li>Nornir 3.1.1 - <code>pip install nornir</code></li>
<li>Nornir-netmiko 0.1.1 - <code>pip install nornir-netmiko</code></li>
<li>Netmiko 3.4.0 - <code>pip install netmiko</code></li>
<li>Nornir-salt 0.4.0 - <code>pip install nornir-salt</code></li>
<li>Tabulate 0.8.3 - <code>pip install tabulate</code></li>
<li>PyYAML 5.3.1 - <code>pip install pyyaml</code></li>
<li>Pytest 6.2.4 - <code>pip install pytest</code></li>
<li>TTP 0.7.2 - <code>pip install ttp</code></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>SALTSTACK Nornir Proxy Minion introduction</title>
            <link>/2021/07/16/saltstack-nornir-proxy-minion-introduction/</link>
            <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
            
            <guid>/2021/07/16/saltstack-nornir-proxy-minion-introduction/</guid>
            <description>This is a guest post by Denis Mulyalin, follow github account and twitter feed for latest updates.
 SALTSTACK Nornir Proxy Minion introduction Network Automation is a complex but interesting topic with a lot of challenges to explore and a lot to learn, defined by one of the vendors as:
 Network automation is the process of automating the configuring, managing, testing, deploying, and operating of physical and virtual devices within a network.</description>
            <content type="html"><![CDATA[<p><em>This is a guest post by Denis Mulyalin, follow <a href="https://github.com/dmulyalin">github account</a> and <a href="https://twitter.com/DMulyalin">twitter feed</a> for latest updates.</em></p>
<hr>
<h1 id="saltstack-nornir-proxy-minion-introduction">SALTSTACK Nornir Proxy Minion introduction</h1>
<p>Network Automation is a complex but interesting topic with a lot of challenges to explore and a lot to learn, defined by one of the <a href="https://www.cisco.com/c/en/us/solutions/automation/network-automation.html">vendors</a> as:</p>
<blockquote>
<p>Network automation is the process of automating the configuring, managing, testing, deploying, and operating of physical and virtual devices within a network.</p>
</blockquote>
<p>This post is an introduction to SALTSTACK and Nornir and how the Network Automation field can benefit from combining them.</p>
<h2 id="nornir-or-and-saltstack">Nornir <del>or</del> and SALTSTACK</h2>
<p>Many systems were developed to address automation aspects of networking, Nornir and SALTSTACK fall in the same category and could be succinctly described as:</p>
<p><strong>Nornir</strong> - <em>is an automation framework written in python to be used with python</em> - it is a general purpose automation system that uses plugins to address specific problems at specific layers.</p>
<p><strong>SALTSTACK</strong> - <em>Built on python, Salt uses simple and human-readable YAML combined with event-driven automation to deploy and configure complex IT systems</em> - it is a general purpose and hierarchical automation system that uses modules to address specific problems at specific levels.</p>
<p>Both systems share many common aspects, such as:</p>
<ul>
<li>Both written in Python and can be directly interfaced using Python API</li>
<li>Both use plugins/modules to interact with devices and external systems</li>
<li>Both are open-source (SALTSTACK community) and available on GitHub</li>
<li>Both follow <em>&ldquo;everything is pluggable and extendable&rdquo;</em> paradigm</li>
</ul>
<p>But, while Nornir targets mainly automation of networks, SALTSTACK was initially developed to automate IT systems - servers, virtual machines, operating systems, applications.</p>
<p>SALT also aims to address a much wider set of use cases compared to Nornir, it has more components, longer history (111,991 commits) and big community. Moreover, SALTSTACK has a Team of developers backing it up and was recently <a href="https://blogs.vmware.com/management/2020/10/vmware-completes-saltstack-acquisition-to-bolster-software-configuration-management-and-infrastructure-automation.html">purchased</a> by VMWare. Worth noting that SALTSTACK has an Enterprise version as well.</p>
<h2 id="nornir-intro">Nornir intro</h2>
<p>Nornir is a Python based framework or package if you&rsquo;d like. That package contains pluggable core that uses plugins to do its work.</p>
<p>Diagram to recap key Nornir components:</p>
<pre><code>    +-------Nornir Framework-------+
    |                              |
    | Inventory       Transform    |
    |  Plugins         Plugins     |
    |     |               |        |
    |  ======Nornir CORE======     |
    |            |                 |
    |         Runners  Processors  |
    |             |          |     |
    |           Tasks &lt;------+     |
    |             |                |
    |     Connection Plugins       |
    |      |              |        |
    |   SSH/API        SSH/API     |
    |      |              |        |
    |   +------+       +------+    |
    |   |DEVICE|       |DEVICE|    |
    |   +------+       +------+    |
    |                              |
    +------------------------------+
</code></pre><p>Plugins can be developed independently of the main Core package and registered during runtime to execute tasks on devices.</p>
<h2 id="saltstack-intro">SALTSTACK intro</h2>
<p>Key aspects of SALT architecture could be summarized as below:</p>
<pre><code>                      |-RUNNERS    |-REACTOR      |-SCHEDULERS
                      |-CLOUD      |-FILE SERVER  |-STATE
                      |-WHEEL      |-AUTH         |-RENDERERS
                      |-MINE       |-PILLAR       |-OUTPUT
                      +------------+--------------+
                                   |
                    |           MASTER             |
                    |                              |
                    +----------Server/VM-----------+
    ENGINES                        |                       API
       |                           |                        |
       |                           |                        |
===========================ZeroMQ  EVENT BUS=============================
                 |                                    |
                 |                                    |
      +------Server/VM-------+              +------Server/VM-------+
      |                      |              |                      |
      |  OS (Windows/Linux)  |              |  OS (Windows/Linux)  |
      |   |-MINION process   |              |   |-PROXY-MINION     |
      |     |-BEACON         |              |     |-BEACON         |
      |     |-GRAINS         |              |     |-GRAINS         |
      |     |-RETURNER       |              |     |-RETURNER       |
      |     |-SCHEDULER      |              |     |-SCHEDULER      |
      |     |-EXECUTION      |              |     |-EXECUTION      |
      |       MODULES        |              |       MODULES        |
      |                      |              |                      |
      +----------------------+              +----------------------+
                                                      |
                                                   SSH/API
                                                      |
                                                   +------+
                                                   |DEVICE|
                                                   +------+
</code></pre><p>SALT Master is the HUB of the overall system, it communicates with Minions to execute various tasks. SALTSTACK uses <a href="https://docs.saltproject.io/en/latest/ref/index.html">modules</a> to address various use cases.</p>
<p>In the simplest master-less case no Master is required and only a Minion process need to run. Most common deployment, however, is a two tier hierarchy system where Master controls many Minions. Each Minion acts as an agent natively running on the Operating System of the server or device being managed.</p>
<p>The two-tier approach works well while you need to manage devices that can run Python and other packages required by Minion. But it falls short when you need to manage systems that do not provide such capabilities and instead could be managed over API (HTTP, Netconf etc.) or SSH/Telnet.</p>
<p>A three-tier hierarchy was developed to accommodate systems that cannot run Minion processes. For that case, special minion process need to run somewhere where it is reachable by the Master and able to talk with the managed device - this type of minion is called proxy-minion.</p>
<p>For completeness it is good to mention that <a href="https://docs.saltproject.io/en/latest/topics/topology/syndic.html">SALT Syndic</a> architecture also exists, that architecture allows to introduce Master of Masters node for big scale deployments. For redundancy purposes several Masters can be deployed in an active-standby manner.</p>
<p>Proxy Minions and Normal minions use execution modules to provide SALT Master and ultimately end-user with functionality to manage target systems/devices. For example, latest (at the time) version of SALT 3003.1 shipped with 529 execution modules each containing several functions. Many execution modules can be used by proxy-minions.</p>
<h2 id="saltstack-how-to-use-it">SALTSTACK how to use it</h2>
<p>The preferred way of interacting manually with SALT is a collection of CLI utilities that you invoke on Master, main ones are <code>salt</code> and <code>salt-run</code>.</p>
<p>For machines/scripts SALT exposes a native <a href="https://docs.saltproject.io/en/latest/ref/clients/index.html#client-apis">Python API</a> same as Nornir. In addition to that, SALT can run REST API server, which acts as a thin wrapper around Python API.</p>
<p>Here is an example of running <code>clock</code> shell command on the remote Linux machine called <em>srv-1</em> through the minion using <code>salt</code> utility on SALT Master:</p>
<pre><code>salt srv-1 cmd.run 'clock'
</code></pre><p>Or, example of running <code>show clock</code> command from SALT-Master on the remote network router called <em>router-1</em> managed over SSH by NAPALM Proxy Minion:</p>
<pre><code>salt router-1 net.cli &quot;show clock&quot;
</code></pre><p>Or same example as above but using <a href="https://docs.saltproject.io/en/latest/ref/clients/index.html#localclient">Python Local Client API</a> on SALT Master:</p>
<pre><code>import salt.client

client = salt.client.LocalClient()

response = client.cmd(tgt=&quot;router-1&quot;, fun=&quot;net.cli&quot;, arg=[&quot;show clock&quot;])
</code></pre><p>Another option to run SALT commands from the CLI on your local machine could be <a href="https://github.com/saltstack/pepper">Pepper Library</a>, which leverages SALT REST API server.</p>
<p>Worth noting that various SALTSTACK web GUI applications were developed as well.</p>
<h2 id="how-nornir-fits-the-picture">How Nornir fits the picture</h2>
<p>SALTSTACK gained prominent capabilities to manage network devices a while ago, mainly thanks to development of <a href="https://docs.saltproject.io/en/latest/topics/network_automation/index.html#napalm">NAPALM proxy-minion</a> module in year 2016.</p>
<p>However, the main drawback of proxy-minion for network automation, or better say, the main drawback of three tier hierarchy for network devices automation is that each network device requires to run dedicated proxy-minion process, each consuming ~100Mbyte of RAM.</p>
<p>If you have somewhat small network of say 50-100 devices (routers, switches, firewalls etc.) you might end up running 50-100 proxy minion processes (one for each managed devices) consuming about 4-10Gbyte of RAM combined.</p>
<p>If your network is of a bigger size and has about 500-1000 devices in it, you might need 40-100Gbyte of RAM to run your proxy-minions.</p>
<p>For a service provider or big enterprise with thousands of devices, the resources needed for the proxy-minions can be significant.</p>
<p>To address this scaling problem we can improve three-tier hierarchy by making single proxy-minion process to manage several devices using Nornir:</p>
<pre><code>                    +------------------------------+
                    |           MASTER             |
                    +------------------------------+
                                   |
                                   |
===========================ZeroMQ  EVENT BUS=============================
                 |                                      |
                 |                                      |
       +------Server/VM-------+            +--------Server/VM---------+
       |                      |            |                          |
       |  OS (Windows/Linux)  |            |  OS (Windows/Linux)      |
       |   |-PROXY-MINION     |            |   |-Nornir-PROXY-MINION  |
       |     |-BEACON         |            |     |-BEACON             |
       |     |-GRAINS         |            |     |-GRAINS             |
       |     |-RETURNER       |            |     |-RETURNER           |
       |     |-SCHEDULER      |            |     |-SCHEDULER          |
       |     |-EXECUTION      |            |     |-EXECUTION          |
       |       MODULES        |            |       MODULES            |
       |                      |            |                          |
       +----------------------+            +--------------------------+
                 |                             |        |        |
              SSH/API                       SSH/API  SSH/API  SSH/API
                 |                             |        |        |
              +------+                      +------+ +------+ +------+
              |DEVICE|                      |DEVICE| |DEVICE| |DEVICE|
              +------+                      +------+ +------+ +------+
</code></pre><p>Integrating Nornir with SALT proxy-minion allows us to manage multiple network devices from single proxy-minion process.</p>
<p>If single Nornir proxy-minion manages 10 network devices, we will decrease RAM resource requirements approximately by a factor of 9 compared to normal proxy-minion.</p>
<p>If we opt for 50 devices per Nornir proxy-minion, resources will decrease by a factor of ~25-30. Or in other words, with 50 devices per proxy-minion and 40 proxy-minion processes one should be able to manage 2000 network devices using about 8Gbyte of RAM.</p>
<p>In addition to addressing scaling problem SALTSTACK and Nornir can deeply complement one another.</p>
<p>For instance, a single proxy-minion process can use several Nornir connection plugins to communicate with devices and switching between Netmiko, Scrapli or NAPALM to push configuration to devices would become a matter of specifying single command line argument:</p>
<pre><code>salt nornir-proxy-1 nr.cfg &quot;loopback 1000&quot; &quot;description 'Configured by SALT and Nornir'&quot; plugin=netmiko
salt nornir-proxy-1 nr.cfg &quot;loopback 1000&quot; &quot;description 'Configured by SALT and Nornir'&quot; plugin=napalm
salt nornir-proxy-1 nr.cfg &quot;loopback 1000&quot; &quot;description 'Configured by SALT and Nornir'&quot; plugin=scrapli
</code></pre><p>Or running any Nornir task plugin by specifying Python import path or path to a file with the code:</p>
<pre><code>salt nornir-proxy-1 nr.task &quot;nornir_napalm.plugins.tasks.napalm_get&quot; getters=&quot;get_facts&quot;
salt nornir-proxy-1 nr.task &quot;salt://path/to/task_function.py&quot;
</code></pre><p>On the flip side, Nornir gains access to SALTSTACK subsystems such as:</p>
<ul>
<li>SALT CLI to work with Nornir framework using SALT Master command line terminal</li>
<li>Exposure to SALT Python API or REST API to interact with network devices via Nornir plugins</li>
<li>SALT Event Bus allowing to build distributed network of proxy-minions with linear scaling-out characteristics</li>
<li>Configuration rendering using SALT text renderers e.g. Jinja2, Mako, Cheetah, Genshi and others with access to SALT pillar, grains or mine systems for data sourcing</li>
<li>Emitting events to event-bus for failed tasks - add SALT Reactor and you have a recipe for event-driven automation</li>
<li>SALT file server to store and download configuration files, custom tasks, tests, lists of commands and actions to perform</li>
<li>Schedulers to run Nornir tasks on a periodic or one-off basis</li>
<li>Returners to emit task&rsquo;s results to external databases - Elasticsearch, MongoDB, MySQL etc. - or to email or text them to slack</li>
<li>Storing devices output to SALT-Mine on a periodic basis to have a snapshot of latest state</li>
<li>SALTSTACK States system to integrate network configuration in work flows of applications provisioning</li>
</ul>
<p>On the output we getting results that can help us, Network Engineers, be less restricted, be more flexible and efficient and put to work all the efforts Open Source community invested in building Nornir and SALTSTACK systems.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Nornir and SALTSTACK both aiming to help people manage their infrastructure in a more efficient way. Both produced by community for community. Both pluggable, extendable, built on Python with Python API readily available to solve your problems.</p>
<p>Combining Nornir and SALTSTACK together gives us something new, something bigger, something that we can work and tinker with, something we can face with to ever growing, complex and intricate world of Network Automation.</p>
<p>Thank you for reading, hope you enjoyed it. Author would like to leave reader with a set of links to explore this topic further:</p>
<ul>
<li>Nornir Proxy Minion <a href="https://salt-nornir.readthedocs.io/en/latest/index.html">documentation</a></li>
<li>SALTSTACK <a href="https://saltproject.io/">website</a></li>
<li>SALTSTACK Network Automation <a href="https://docs.saltproject.io/en/latest/topics/network_automation/index.html">article</a></li>
<li>Remarkable Mircea Ulinic <a href="https://mirceaulinic.net/">blog</a> with SALT Network Automation articles</li>
<li>Informative &ldquo;Network Automation at scale&rdquo; <a href="https://ripe74.ripe.net/presentations/18-RIPE-74-Network-automation-at-scale-up-and-running-in-60-minutes.pdf">presentation</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>How To: Filtering Deep Dive</title>
            <link>/2021/04/19/how-to-filtering-deep-dive/</link>
            <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
            
            <guid>/2021/04/19/how-to-filtering-deep-dive/</guid>
            <description>This is a guest post by Daniel Teycheney, for more content like this and other interesting stuff you can visit the following youtube channel, github account, blog and twitter feed.
 nornir is a first-class automation framework, so if you are reading this page, you&amp;rsquo;re probably here to learn more. One of the aspects of which sets nornir apart is filtering.
A new how-to guide has been published to the official documentation, walking through a series of use-cases and examples on how to leverage the power and flexibility of nornir filtering.</description>
            <content type="html"><![CDATA[<p><em>This is a guest post by Daniel Teycheney, for more content like this and other interesting stuff you can visit the following <a href="https://www.youtube.com/channel/UCTjhvZ6rj2Hya4nszBfXoRg">youtube channel</a>, <a href="https://github.com/writememe">github account</a>, <a href="https://blog.danielteycheney.com/">blog</a> and <a href="https://twitter.com/danielteycheney">twitter feed</a>.</em></p>
<hr>
<p>nornir is a first-class automation framework, so if you are reading this page, you&rsquo;re probably here to learn more. One of the aspects of which sets nornir apart is filtering.</p>
<p>A new how-to guide has been published to the official documentation, walking through a series of use-cases and examples on how to leverage the power
and flexibility of <code>nornir filtering</code>.</p>
<p>Some of the topics covered are:</p>
<ul>
<li>Introduction into custom inventory data</li>
<li>How to store, access, view and troubleshoot custom data</li>
<li>Basic/intermediate filtering using the <code>filter</code> method</li>
<li>Advanced filtering using the <code>F</code> object</li>
<li>Advanced filtering using filter functions</li>
</ul>
<p>A sample inventory is weaved throughout the how-to guide, so that the concepts being portrayed are contextually revelant to a real world use case. Below is the
link to the how-to guide:</p>
<p><a href="https://nornir.readthedocs.io/en/latest/howto/filtering_deep_dive.html">nornir official documentation - filtering deep dive</a></p>
<h2 id="further-resources">Further resources</h2>
<p>If you&rsquo;d like to learn more, below are some links to various resources which also touch on nornir filtering:</p>
<p><a href="https://github.com/nornir-automation/nornir/discussions/647">nornir filtering cheatsheet</a><br>
<a href="https://github.com/dravetech/nornir-workshop/blob/master/notebooks/3_filtering.ipynb">nornir-workshop - jupyter notebook filtering examples</a><br>
<a href="https://github.com/dravetech/nornir-workshop/blob/master/nornir-workshop.pdf">nornir-workshop - Full Presentation</a><br>
<a href="https://github.com/writememe/nornir-filtering-demo">nornir-filtering-demo - repository</a><br>
<a href="https://www.youtube.com/watch?v=aGyLKITj4Nw">nornir-filtering-demo - Video</a></p>
]]></content>
        </item>
        
        <item>
            <title>Nornir 3 beta</title>
            <link>/2020/06/18/nornir-3-beta/</link>
            <pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/06/18/nornir-3-beta/</guid>
            <description>I am happy to announce that nornir3 is in beta for you to test. The truth is that it&amp;rsquo;s been out already for a while but at this point I am confident it&amp;rsquo;s stable enough to open it to the wider public for testing.
To install nornir beta you will need to execute the following command:
$ pip install --pre &amp;#34;nornir&amp;gt;=3.0.0b0&amp;#34; Don&amp;rsquo;t forget the --pre option as otherwise pip won&amp;rsquo;t let you install it as it&amp;rsquo;s considered a pre-release.</description>
            <content type="html"><![CDATA[<p>I am happy to announce that nornir3 is in beta for you to test. The truth is that it&rsquo;s been out already for a while but at this point I am confident it&rsquo;s stable enough to open it to the wider public for testing.</p>
<p>To install nornir beta you will need to execute the following command:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ pip install --pre <span style="color:#e6db74">&#34;nornir&gt;=3.0.0b0&#34;</span>
</code></pre></div><p>Don&rsquo;t forget the <code>--pre</code> option as otherwise <code>pip</code> won&rsquo;t let you install it as it&rsquo;s considered a pre-release.</p>
<p>There are many new features and some changes but the main change is that <code>nornir</code> won&rsquo;t ship with plugins, instead plugins will live in their own repository. This should minimize the amount of dependencies needed to deploy nornir and also allow maintainers to better maintain the plugins they are experts on :)</p>
<p>To find plugins you can visit <a href="/nornir/plugins/">the plugin repository</a> and if you want to list your own just open a PR.</p>
<p>Instructions for installing plugins is plugin specific but in most cases it will be just a matter of using pip. For instance:</p>
<pre><code>$ pip install nornir-napalm nornir-utils nornir-jinja2
</code></pre><p>Plugins&rsquo; documentation should have more info about it.</p>
<p>You can find the docs <a href="https://nornir.readthedocs.io/en/3.0.0/">here</a> and the upgrading notes <a href="https://nornir.readthedocs.io/en/3.0.0/upgrading/2_to_3.html">here</a></p>
<p>Finally, a working example using nornir3:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir_napalm.plugins.tasks <span style="color:#f92672">import</span> napalm_cli

nr <span style="color:#f92672">=</span> InitNornir(
    inventory<span style="color:#f92672">=</span>{
        <span style="color:#e6db74">&#34;plugin&#34;</span>: <span style="color:#e6db74">&#34;SimpleInventory&#34;</span>,
        <span style="color:#e6db74">&#34;options&#34;</span>: {
            <span style="color:#e6db74">&#34;host_file&#34;</span>: <span style="color:#e6db74">&#34;inventory/hosts.yaml&#34;</span>,
            <span style="color:#e6db74">&#34;group_file&#34;</span>: <span style="color:#e6db74">&#34;inventory/groups.yaml&#34;</span>,
            <span style="color:#e6db74">&#34;defaults_file&#34;</span>: <span style="color:#e6db74">&#34;inventory/defaults.yaml&#34;</span>,
        }
    },
    dry_run<span style="color:#f92672">=</span>True,
)

result <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>run(
    napalm_cli,
    commands<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;show version&#34;</span>, <span style="color:#e6db74">&#34;show interfaces&#34;</span>],
)

<span style="color:#66d9ef">print</span>(result[<span style="color:#e6db74">&#34;rtr00&#34;</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>result[<span style="color:#e6db74">&#34;show version&#34;</span>])
</code></pre></div><p>Which is pretty much what you are used to with the difference the import path for <code>napalm_cli</code> is now different and points to the plugin library.</p>
<p>Feel free to check the documentation, try it out and contact me on slack, open issues and/or PRs if you find issues or have questions.</p>
]]></content>
        </item>
        
        <item>
            <title>Tutorial: Combining Nornir with pyATS</title>
            <link>/2020/05/13/tutorial-combining-nornir-with-pyats/</link>
            <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/05/13/tutorial-combining-nornir-with-pyats/</guid>
            <description>This is a guest post by John McGovern (IPvZero), for more content like this and other interesting stuff you can visit the following youtube channel, github account, and twitter feed.
 This tutorial aims to provide a simple use-case for combining Nornir and pyATS together in order to profile your current network configurations and implement desired state - as specified in host variable definition files.
The workflow we will follow in this tutorial will be first to:</description>
            <content type="html"><![CDATA[<p><em>This is a guest post by John McGovern (IPvZero), for more content like this and other interesting stuff you can visit the following <a href="https://youtube.com/c/IPvZero">youtube channel</a>, <a href="https://github.com/IPvZero">github account</a>, and <a href="https://twitter.com/IPvZero">twitter feed</a>.</em></p>
<hr>
<p>This tutorial aims to provide a simple use-case for combining <a href="https://github.com/nornir-automation/nornir/">Nornir</a> and <a href="https://pubhub.devnetcloud.com/media/pyats/docs/getting_started/index.html">pyATS</a> together in order to profile your current network configurations and implement desired state - as specified in host variable definition files.</p>
<p>The workflow we will follow in this tutorial will be first to:</p>
<ul>
<li>Deploy OSPF desired state using Nornir</li>
<li>Immediately deploying pyATS to capture a golden image profile of this &ldquo;desired state&rdquo;</li>
</ul>
<p>After we have conducted the initial steps we will then deploy a python script (<code>Pynir.py</code>) that will:</p>
<ul>
<li>Invoke pyATS to profile the current OSPF configuration and compare it to the golden image previously captured.</li>
<li>If pyATS detects a difference – the terminal will prompt an alert signalling that OSPF in currently out of sync with desired state</li>
<li>The script will then give the user the option to rollback to desired state</li>
<li>Should the user answer <strong>No</strong> – the script ends and all current OSPF settings and Diff artefacts are left and are able to be inspected</li>
<li>Should the user answer <strong>Yes</strong> – the script invokes Nornir to first erase all OSPF configurations currently in the network, before reimplementing desired state by pulling information from host variable definition files and leveraging jinja2 templating.</li>
<li>Lastly, if the script detects that the current OSPF profile is identical to the OSPF desired state, it will generate a message informing us that all current configurations are matching our desired state.</li>
</ul>
<p>To begin, let&rsquo;s first look at the directory structure and setup:</p>
<pre><code>ipvzero@MSI:~/Nornir-Blog$ tree
.
├── Pynir.py
├── capture-golden
├── config.yaml
├── defaults.yaml
├── groups.yaml
├── host_vars
│   ├── R1.yaml
│   ├── R2.yaml
│   ├── R3.yaml
│   ├── R4.yaml
│   ├── R5.yaml
│   ├── R6.yaml
│   ├── R7.yaml
│   └── R8.yaml
├── hosts.yaml
├── nornir-ospf.py
├── nornir.log
├── templates
│   └── ospf.j2
└── testbed.yaml

2 directories, 18 files
</code></pre><p>As you can see we can our basic Nornir yaml files:</p>
<ul>
<li><code>hosts.yaml</code></li>
<li><code>groups.yaml</code></li>
<li><code>defaults.yaml</code></li>
</ul>
<p>Notice that there is also a <code>testbed.yaml</code> file to allow pyATS to connect into and profile the network. Next, you&rsquo;ll notice we also have two directories. The first one called <code>host_vars</code> which will house our OSPF host variables (note: you can use the <code>hosts.yaml</code> file instead, but I have chosen to create a separate directory to perform this task). The second is called <code>templates</code> which will house our OSPF Jinja2 template.</p>
<p>Importantly, you&rsquo;ll notice a <code>capture-golden</code> file. This is a very simple bash script used to capture our &ldquo;golden&rdquo; snapshot of our desired OSPF state. It simply executes a pyATS command. You can type this command by hand should you wish, but since the output directory has to remain the same since it will be referenced by the <code>Pynir.py</code> script – for consistency, I have elected to execute it from a bash script to prevent me mistyping the output destination. Let&rsquo;s look inside to see what&rsquo;s going on:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>pyats learn ospf --testbed-file testbed.yaml --output desired-ospf
</code></pre></div><p>As you can see the bash script simply tells pyATS to learn the network&rsquo;s OSPF configurations and save the output into a directory called <code>desired-ospf</code>. This directory will act as our reference point.</p>
<p>Let&rsquo;s take a look inside the <code>host_vars</code> directory and see what our host variable definition files look like. For brevity, let&rsquo;s just look at <code>R1.yaml</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">OSPF</span>:
    <span style="color:#66d9ef">process</span>: <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">id </span>: <span style="color:#ae81ff">1.1.1.1</span>
    <span style="color:#66d9ef">networks</span>:
      - <span style="color:#66d9ef">net</span>: <span style="color:#ae81ff">192.168.1.0</span>
        <span style="color:#66d9ef">wildcard</span>: <span style="color:#ae81ff">0.0.0.255</span>
        <span style="color:#66d9ef">area</span>: <span style="color:#ae81ff">0</span>
      - <span style="color:#66d9ef">net</span>: <span style="color:#ae81ff">192.168.10.0</span>
        <span style="color:#66d9ef">wildcard</span>: <span style="color:#ae81ff">0.0.0.255</span>
        <span style="color:#66d9ef">area</span>: <span style="color:#ae81ff">0</span>
</code></pre></div><p>We have a very basic OSPF setup which lists the process ID number, the RID, and the network statement configs for the router. R2 through to R8 have very similar configurations. As this is simply a demo, I have created easily identifiable variations between files. For example, R5 uses OSPF process ID of 5, with a RID of 5.5.5.5 and the networks it advertises are &ldquo;192.168.5.0&rdquo; and &ldquo;192.168.50.0&rdquo;. These files represent our desired state. In other words, this is what our network &ldquo;should look like&rdquo;.</p>
<p>Next, let&rsquo;s look inside the templates directory and open our <code>ospf.j2</code> file:</p>
<pre><code class="language-jinja2" data-lang="jinja2">router ospf {{ host.OSPF.process }}
  router-id {{ host.OSPF.id }}
  {% for n in host.OSPF.networks %}
  network {{ n.net }} {{ n.wildcard }} area {{ n.area }}
  {% endfor %}
</code></pre><p>This template will simply reference the Keys specificed in our host_var yaml files and populate the template with their corresponding Values to build our desired OSPF configuration.</p>
<p>You will notice we have a <code>nornir-ospf.py</code> script. This is the script we will use to first initially push our desired state onto the routers. This script simply pulls desired state from our <code>host_vars</code> and pushes them through our Jinja2 template onto the network. In other words, it does not remove old stale configs (like <code>Pynir.py</code> will) so the assumption here is that we are working with a blank slate on the devices. Let&rsquo;s look inside the script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir.plugins.tasks.data <span style="color:#f92672">import</span> load_yaml
<span style="color:#f92672">from</span> nornir.plugins.tasks.text <span style="color:#f92672">import</span> template_file
<span style="color:#f92672">from</span> nornir.plugins.functions.text <span style="color:#f92672">import</span> print_result
<span style="color:#f92672">from</span> nornir.plugins.tasks.networking <span style="color:#f92672">import</span> netmiko_send_config

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">load_ospf</span>(task):
    data <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>load_yaml,file<span style="color:#f92672">=</span>f<span style="color:#e6db74">&#39;./host_vars/{task.host}.yaml&#39;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;OSPF&#34;</span>] <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>result[<span style="color:#e6db74">&#34;OSPF&#34;</span>]
    r <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>template_file, template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ospf.j2&#34;</span>, path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./templates&#34;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>] <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>result
    output <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>]
    send <span style="color:#f92672">=</span> output<span style="color:#f92672">.</span>splitlines()
    task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_config, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;IPvZero Commands&#34;</span>, config_commands<span style="color:#f92672">=</span>send)

nr <span style="color:#f92672">=</span> InitNornir()
results <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>run(load_ospf)
print_result(results)
</code></pre></div><p>This is a fairly typical script which will pull information from the desired state specified in our <code>host_vars</code> yaml files, save the information and use those values to build our configurations based on the syntax specified in our Jinja2 template. Nornir then invokes Netmiko to push those configurations out to all of our respective devices in the network. Now that we understand what&rsquo;s going on, let&rsquo;s execute that script and push our desired state onto our otherwise blank network:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/6.png?raw=true" alt="alt text"></p>
<p>With our desired state now present on the network, let&rsquo;s immediately use pyATS to build a detailed profile of that configuration and grab our &ldquo;golden&rdquo; snapshot. Let&rsquo;s execute the <code>capture-golden</code> script:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/7.png?raw=true" alt="alt text"></p>
<p>pyATS has successfully profiled our desired state and you will notice the addition of a new directory called <code>desired-ospf</code> which houses of all of our detailed OSPF information for each device.
Now that we have pushed our desired state and successfully created a snapshot for future comparison, let&rsquo;s look at the main script which we will use for our OSPF management going forward, <code>Pynir.py</code>. The script is relatively long so let&rsquo;s break it down into sections. First we begin with our imports - and I have also included a Pyfiglet banner for purely aesthetic purposes (who doesn&rsquo;t like to make their scripts pretty, right?).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> subprocess
<span style="color:#f92672">import</span> colorama
<span style="color:#f92672">from</span> colorama <span style="color:#f92672">import</span> Fore, Style
<span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir.plugins.tasks.networking <span style="color:#f92672">import</span> netmiko_send_command
<span style="color:#f92672">from</span> nornir.plugins.functions.text <span style="color:#f92672">import</span> print_result, print_title
<span style="color:#f92672">from</span> nornir.plugins.tasks.networking <span style="color:#f92672">import</span> netmiko_send_config
<span style="color:#f92672">from</span> nornir.plugins.tasks.data <span style="color:#f92672">import</span> load_yaml
<span style="color:#f92672">from</span> nornir.plugins.tasks.text <span style="color:#f92672">import</span> template_file
<span style="color:#f92672">from</span> pyfiglet <span style="color:#f92672">import</span> Figlet

nr <span style="color:#f92672">=</span> InitNornir(config_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;config.yaml&#34;</span>)
clear_command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;clear&#34;</span>
os<span style="color:#f92672">.</span>system(clear_command)
custom_fig <span style="color:#f92672">=</span> Figlet(font<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;isometric3&#39;</span>)
<span style="color:#66d9ef">print</span>(custom_fig<span style="color:#f92672">.</span>renderText(<span style="color:#e6db74">&#39;pyNIR&#39;</span>))
</code></pre></div><p>Next, we create a custom function called <code>clean_ospf</code>. The first challenge of the script was to find a way to strip away all OSPF configurations, should that be required. The problem with automating over legacy devices with no API capabilities, however, is that we are heavily reliant on screen-scraping – an inelegant and unfortunately necessary solution. To do so, I made the decision to use Nornir to execute a <code>show run | s ospf</code> on all devices, saved the resulting output, and began screen-scraping to identify digits in the text. The aim here was to identify any OSPF process IDs which could then be extracted and used to negate the process by executing a <code>no router opsf</code>; followed by the relevant process ID. The challenge here is that the show command output would also include area ID information – and OSPFs most common area configuration is for area 0. Of course <code>router ospf 0</code> is not a legal command, so in order to avoid this I included a conditional statement that would skip over and <code>continue</code> past any number zeros in the output. The second challenge would be avoiding needless repetition. Should OSPF be configured via the interfaces, the resulting show output could, for example, have multiple: <code>ip ospf 1 area 0</code>
<code>ip ospf 1 area 0</code>.
Parsing out this information could lead to the script executing multiple <code>no router ospf 1</code>; commands which is, of course, unnecessary. To avoid this, I elected to push all output into a python list, and from there remove all duplicates. There is still, however, an inefficiency given that the show output could, for example, show a multi-area OSPF configuration all within the same process. This could result in a script seeing an <code>ip ospf 1 area 5</code> configuration and attempting to execute a superfluous <code>no router ospf 5</code>. However, given that the script has protections against repetitive execution, and that routers will have limited areas configured per device (maybe 3 different areas at most per device, if at all), I made the decision that this was an acceptable inefficiency. Like I say, there is nothing elegant about screen-scraping and sometimes a 90% solution is better than no solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clean_ospf</span>(task):
    r <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_command, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Identifying Current OSPF&#34;</span>, command_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;show run | s ospf&#34;</span>)
    output <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>result
    my_list <span style="color:#f92672">=</span> []
    num <span style="color:#f92672">=</span> [int(s) <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> output<span style="color:#f92672">.</span>split() <span style="color:#66d9ef">if</span> s<span style="color:#f92672">.</span>isdigit()]
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> num:
        <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">continue</span>
        my_list<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;no router ospf &#34;</span> <span style="color:#f92672">+</span> str(x))
    my_list <span style="color:#f92672">=</span> list(dict<span style="color:#f92672">.</span>fromkeys(my_list))
    <span style="color:#66d9ef">for</span> commands <span style="color:#f92672">in</span> my_list:
        task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_config, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Removing Current OSPF&#34;</span>, config_commands<span style="color:#f92672">=</span>commands)

    desired_ospf(task)
</code></pre></div><p>Now we have the ability to remove all current OSPF configuration, we create a custom function called <code>desired_ospf</code>. This is almost identical to the earlier script and simply builds our configuration from <code>host_vars</code> definition files and pushes them through our jinja2 OSPF template and out to the devices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">desired_ospf</span>(task):
    data <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>load_yaml, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Pulling from Definition Files&#34;</span>, file<span style="color:#f92672">=</span>f<span style="color:#e6db74">&#39;./host_vars/{task.host}.yaml&#39;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;OSPF&#34;</span>] <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>result[<span style="color:#e6db74">&#34;OSPF&#34;</span>]
    r <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>template_file, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Building Desired State&#34;</span>, template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ospf.j2&#34;</span>, path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./templates&#34;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>] <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>result
    output <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>]
    send <span style="color:#f92672">=</span> output<span style="color:#f92672">.</span>splitlines()
    task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_config, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Implementing OSPF Desired State&#34;</span>, config_commands<span style="color:#f92672">=</span>send)
</code></pre></div><p>The next part of the script is effectively what executes first and precedes our two custom functions (with will only execute upon certain conditions). Let&rsquo;s look at it. First we use the OS and Subprocess python modules to first execute the shell command <code>pyats learn ospf --testbed-file testbed.yaml --output ospf-current</code> to relearn the current state of the network&rsquo;s OSPF configs, and then run a diff between the current configs, and our previously saved golden config – <code>pyats diff desired-ospf/ ospf-current –output ospfdiff</code>. We then read the output and search for the string <code>Diff can be found</code>. If a difference is found, we are alerted to the discrepancy and offered the choice to rollback to our desired state.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">current <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pyats learn ospf --testbed-file testbed.yaml --output ospf-current&#34;</span>
os<span style="color:#f92672">.</span>system(current)
command <span style="color:#f92672">=</span> subprocess<span style="color:#f92672">.</span>run([<span style="color:#e6db74">&#34;pyats&#34;</span>, <span style="color:#e6db74">&#34;diff&#34;</span>, <span style="color:#e6db74">&#34;desired-ospf/&#34;</span>, <span style="color:#e6db74">&#34;ospf-current&#34;</span>, <span style="color:#e6db74">&#34;--output&#34;</span>, <span style="color:#e6db74">&#34;ospfdiff&#34;</span>], stdout<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE)
stringer <span style="color:#f92672">=</span> str(command)
<span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;Diff can be found&#34;</span> <span style="color:#f92672">in</span> stringer:
    os<span style="color:#f92672">.</span>system(clear_command)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>CYAN <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;#&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">70</span>)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>RED <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;ALERT: &#34;</span> <span style="color:#f92672">+</span> Style<span style="color:#f92672">.</span>RESET_ALL <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;CURRENT OSPF CONFIGURATIONS ARE NOT IN SYNC WITH DESIRED STATE!&#34;</span>)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>CYAN <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;#&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">70</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
    answer <span style="color:#f92672">=</span> input(Fore<span style="color:#f92672">.</span>YELLOW <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;Would you like to reverse the current OSPF configuration back to its desired state? &#34;</span> <span style="color:#f92672">+</span> Style<span style="color:#f92672">.</span>RESET_ALL <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&lt;y/n&gt;: &#34;</span>
)
</code></pre></div><p>Should we answer &ldquo;y&rdquo; and affirm our decision to rollback, the script will first remove all current ospf and diff artefacts before calling our <code>clean_ospf</code> custom function, which, in turn, calls our <code>desired-ospf</code> function and prints the output.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#66d9ef">if</span> answer <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;y&#34;</span>:
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>() <span style="color:#f92672">-&gt;</span> None:
            clean_up <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rm -r ospfdiff ospf-current&#34;</span>
            os<span style="color:#f92672">.</span>system(clean_up)
            os<span style="color:#f92672">.</span>system(clear_command)
            nr <span style="color:#f92672">=</span> InitNornir(config_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;config.yaml&#34;</span>)
            output <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>clean_ospf)
            print_title(<span style="color:#e6db74">&#34;REVERSING OSPF CONFIGURATION BACK INTO DESIRED STATE&#34;</span>)
            print_result(output)

        <span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
                main()
</code></pre></div><p>Should we choose <strong>not</strong> to rollback, however, and instead want to inspect those changes in detail - by selecting &ldquo;n&rdquo; the script simply terminates and leaves all artefacts for our inspection.</p>
<p>Lastly, should the script detect no changes between the current state of our OSPF network and the configurations in our golden capture – the script simply ends and informs us that all OSPF configurations are matching desired state:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">else</span>:
    clean_up <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rm -r ospfdiff ospf-current&#34;</span>
    os<span style="color:#f92672">.</span>system(clean_up)
    os<span style="color:#f92672">.</span>system(clear_command)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">75</span>)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>GREEN <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;Good news! OSPF configurations are matching desired state!&#34;</span> <span style="color:#f92672">+</span> Style<span style="color:#f92672">.</span>RESET_ALL)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">75</span>)

</code></pre></div><h2 id="demo---lets-break-the-network">Demo - Let&rsquo;s Break The Network!</h2>
<p>Now that we understand the logic of the script, let&rsquo;s perform a demo and see the workflow in action. Now remember, we have already deployed our initial desired state and captured that snapshot using both the <code>nornir-ospf.py</code> and <code>capture-golden</code> scripts. Let&rsquo;s first &ldquo;break&rdquo; the network by adding some unwanted OSPF configurations on R8:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/14.png?raw=true" alt="alt text"></p>
<p>Now the current state of our OSPF network does not match the configuration specified in our desired state. Let&rsquo;s run the <code>Pynir.py</code> script and see if it detects the change. <code>Pynir.py</code> first starts learning the current OSPF configurations:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/15.png?raw=true" alt="alt text"></p>
<p>The change is detected and we are both notified and given the option to rollback. This time, we first want to inspect the changes, so let&rsquo;s answer &ldquo;n&rdquo; for No:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/16.png?raw=true" alt="alt text"></p>
<p>The script terminates and leaves the relevant artefacts which we are free to inspect (notice the new directories <code>ospf-current</code> and <code>ospfdiff</code>):</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/17.png?raw=true" alt="alt text"></p>
<p>We can now freely examine these changes and decide if we want to erase them by performing a rollback, or leave them and updating our OSPF definitions:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/18.png?raw=true" alt="alt text"></p>
<p>Upon examination it is clear now that these configuration are certainly not meant to be present in the network. We then rerun Pynir, this time choosing &ldquo;y&rdquo; to rollback to our desired state:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/19.png?raw=true" alt="alt text"></p>
<p>This selection triggers Nornir to execute our custom functions that remove all current OSPF configs and artefacts before redeploying OSPF as specified in our <code>host_vars</code> definition files.</p>
<p>First the OSPF configurations are identified by the show output, and then negated:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/20.png?raw=true" alt="alt text"></p>
<p>Pynir then pulls out desired state from our host varables, builds our configuration using the Jinja2 template, and pushes out the config: <img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/21.png?raw=true" alt="alt text"></p>
<p>For our final validation, let&rsquo;s rerun the script and ensure that we are now in compliance with our desired state:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/22.png?raw=true" alt="alt text"></p>
<p>Excellent! Everything is back to the way it should be.</p>
<p>As you can see, combining Nornir with pyATS can allow us to easily monitor and rollback our network to ensure we are compliant with our desired state of the network. As demonstrated, the largest challenge was finding a workaround to remove all undesired OSPF configurations. With modern devices with APIs, with options for candidate configurations, etc, this problem vanishes. Unfortunately, however, we still need to deal with older devices that were not built with automation in mind, and we have to create inventive and sometimes inefficient workarounds to solve a particular problem. This script is an attempt at doing that.</p>
<p>You can download the script and all subsequent configurations at:
<a href="https://github.com/IPvZero/pynir">https://github.com/IPvZero/pynir</a></p>
]]></content>
        </item>
        
        <item>
            <title>how many threads are enough threads?</title>
            <link>/2020/05/01/how-many-threads-are-enough-threads/</link>
            <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/05/01/how-many-threads-are-enough-threads/</guid>
            <description>The other night there was a discussion about python multi-threading on the nornir channel on slack so I decided to do some benchmarks and explain a couple of things. I am by no means an expert on the topic, I mostly know enough to be scared about the topic and to test assumptions to avoid surprises. I am also going to try to simplify things a bit so apologies in advanced if something is slightly inaccurate.</description>
            <content type="html"><![CDATA[<p>The other night there was a discussion about python multi-threading on the nornir channel on <a href="https://networktocode.herokuapp.com/">slack</a> so I decided to do some benchmarks and explain a couple of things. I am by no means an expert on the topic, I mostly know enough to be scared about the topic and to test assumptions to avoid surprises. I am also going to try to simplify things a bit so apologies in advanced if something is slightly inaccurate. Feel free to let me know if you think something needs further explanation or clarification.</p>
<p>The first thing you need to know is what a thread is, according to the <a href="https://en.wikipedia.org/wiki/Thread_(computing)">wikipedia</a> &ldquo;a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system&rdquo;. The TL;DR; is that a thread is something you can put on a CPU core to be executed. Threads are somewhat expensive to create and manage as the OS needs to maintain several datastructures and run complex <a href="https://en.wikipedia.org/wiki/Scheduling_(computing)">algorithms</a> so an alternative to threads are <a href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a>. Coroutines offer similar functionality to OS threads but are managed by a runtime instead of by the operating system and are much more lightweight than OS threads. You probably heard about asyncio or golang&rsquo;s goroutines, those are examples of coroutine implementations.</p>
<p>Second thing you need to know is you can only run as many threads concurrently as cores you have available (twice with technologies like hyperthreading), however, computers have mechanisms to put threads in an idle state while waiting for some event to occur. For instance, if a python program runs <code>time.sleep(1)</code> it&rsquo;s going to go into this state for 1 second, during that second the program won&rsquo;t consume any CPU, and, when the time comes, the program will be woken up and resume operations. This same technique can be used when waiting for IO operations, for instance, when trying to read/write to disk or when waiting for the network to send you some information. Because those operations are several orders of magnitude slower than executing CPU instructions it is worth trying to parallelize as many of those operations as possible. If you have heard the term &ldquo;IO-bound program&rdquo;, this is a summary of what it means.</p>
<h2 id="testing-assumptions">Testing assumptions</h2>
<p>Now that we are experts on CPU design and have read all the research ever written around the topic of schedulers, let&rsquo;s design a simple test; we are going to simulate an IO-bound application by pretending we are going to connect to 10.000 devices. The application won&rsquo;t really connect to any device, instead it will just go to sleep for a given amount of time. This time we are sleeping should simulate RTT.</p>
<p>Note that this is a very simple test and doesn&rsquo;t really consume the same resources that a program connecting to real devices would consume (sockets, file descriptors, etc), resources that would add up and could cause side-effects, specially if you run the code on a shared machine. Quoting your favorite physics teacher <a href="https://xkcd.com/669/">&ldquo;this only works in the vacuum with no friction&rdquo;</a></p>
<p>Some of the things I want to see with the tests we are going to perform is:</p>
<ol>
<li>How does RTT affect the execution of the program</li>
<li>How many threads are worth creating given they are expensive to create and manage under different RTTs</li>
<li>How helpful coroutines are, are they a fad or do they solve an actual problem?</li>
</ol>
<h3 id="counting-threads-with-nornir">Counting threads with nornir</h3>
<p>To see how many is worth using when attempting to parallelize the connection to 10.000 devices using different RTTs we are going to use <code>nornir</code>. A continuation you can see the script (note it&rsquo;s using a beta version of nornir 3.0 so it might not work out of the box if you try to execute it with nornir 2.0, however, it shouldn&rsquo;t affect performance):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> time

<span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir.core.inventory <span style="color:#f92672">import</span> Defaults, Groups, Hosts,
                                  Host, Inventory
<span style="color:#f92672">from</span> nornir.core.plugins.inventory <span style="color:#f92672">import</span> InventoryPluginRegister
<span style="color:#f92672">from</span> nornir.core.task <span style="color:#f92672">import</span> Task


NUM_DEVICES <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestInv</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Fake inventory that generates hosts dynamically
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">load</span>(self) <span style="color:#f92672">-&gt;</span> Inventory:
        hosts <span style="color:#f92672">=</span> Hosts()
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, NUM_DEVICES):
            name <span style="color:#f92672">=</span> f<span style="color:#e6db74">&#34;dev{i}&#34;</span>
            hosts[name] <span style="color:#f92672">=</span> Host(name)
        <span style="color:#66d9ef">return</span> Inventory(
          hosts<span style="color:#f92672">=</span>hosts, groups<span style="color:#f92672">=</span>Groups(), defaults<span style="color:#f92672">=</span>Defaults()
        )


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fake_task</span>(task: Task, sleep_time: float) <span style="color:#f92672">-&gt;</span> None:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    fake task that simulates RTT
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    time<span style="color:#f92672">.</span>sleep(sleep_time)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(num_workers: int, sleep_time: float) <span style="color:#f92672">-&gt;</span> None:
    InventoryPluginRegister<span style="color:#f92672">.</span>register(<span style="color:#e6db74">&#34;test-inv&#34;</span>, TestInv)

    nr <span style="color:#f92672">=</span> InitNornir(
      inventory<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;plugin&#34;</span>: <span style="color:#e6db74">&#34;test-inv&#34;</span>},
      core<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;num_workers&#34;</span>: num_workers},
    )
    nr<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>fake_task, sleep_time<span style="color:#f92672">=</span>sleep_time)


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    num_workers <span style="color:#f92672">=</span> int(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>])
    sleep_time <span style="color:#f92672">=</span> float(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">2</span>])
    main(num_workers, sleep_time)
</code></pre></div><p>Great, now let&rsquo;s see the results of running this with different parameters. First, with an RTT of 50ms:</p>
<pre><code>python script.py 100 0.05  0.78s user 0.29s system 19% cpu 5.532 total
python script.py 200 0.05  0.79s user 0.34s system 39% cpu 2.854 total
python script.py 500 0.05  0.65s user 0.37s system 73% cpu 1.389 total
python script.py 1000 0.05  0.81s user 0.37s system 118% cpu 0.995 total
python script.py 1500 0.05  0.73s user 0.48s system 125% cpu 0.969 total
python script.py 2000 0.05  0.78s user 0.47s system 125% cpu 0.993 total
python script.py 5000 0.05  0.78s user 0.47s system 126% cpu 0.987 total
python script.py 10000 0.05  0.82s user 0.37s system 123% cpu 0.962 total
</code></pre><p>Now, with an RTT of 100ms:</p>
<pre><code>python script.py 100 0.1  0.77s user 0.30s system 10% cpu 10.551 total
python script.py 200 0.1  0.75s user 0.32s system 19% cpu 5.424 total
python script.py 500 0.1  0.79s user 0.35s system 47% cpu 2.376 total
python script.py 1000 0.1  0.82s user 0.35s system 84% cpu 1.391 total
python script.py 1500 0.1  0.86s user 0.56s system 119% cpu 1.192 total
python script.py 2000 0.1  0.89s user 0.62s system 128% cpu 1.177 total
python script.py 5000 0.1  0.89s user 0.84s system 136% cpu 1.266 total
python script.py 10000 0.1  1.08s user 0.74s system 140% cpu 1.292 total
</code></pre><p>A continuation with 300ms:</p>
<pre><code>python script.py 100 0.3  0.82s user 0.24s system 3% cpu 31.016 total
python script.py 200 0.3  0.74s user 0.27s system 6% cpu 15.381 total
python script.py 500 0.3  0.75s user 0.30s system 16% cpu 6.360 total
python script.py 1000 0.3  0.73s user 0.38s system 33% cpu 3.354 total
python script.py 1500 0.3  0.82s user 0.42s system 50% cpu 2.460 total
python script.py 2000 0.3  0.94s user 0.42s system 67% cpu 2.004 total
python script.py 5000 0.3  1.15s user 1.28s system 154% cpu 1.575 total
python script.py 10000 0.3  1.14s user 1.04s system 141% cpu 1.535 total
</code></pre><p>And finally, with an RTT of 1s, just because reasons:</p>
<pre><code>python script.py 100 1  0.70s user 0.28s system 0% cpu 1:40.55 total
python script.py 200 1  0.75s user 0.19s system 1% cpu 50.445 total
python script.py 500 1  0.64s user 0.30s system 4% cpu 20.335 total
python script.py 1000 1  0.77s user 0.28s system 10% cpu 10.360 total
python script.py 1500 1  0.73s user 0.39s system 15% cpu 7.364 total
python script.py 2000 1  0.86s user 0.37s system 22% cpu 5.507 total
python script.py 5000 1  1.04s user 0.79s system 60% cpu 3.005 total
python script.py 10000 1  1.43s user 1.11s system 97% cpu 2.598 total
</code></pre><p>As you can see latency has a huge impact. If latency is low (~50ms), the cost of creating a large amount of threads is relatively high compared to the time each thread is idle so going from 200 threads to 500 threads doesn&rsquo;t gain you a lot but it increase CPU consumption by 34%. With a latency of 100ms you can see the same effect going from 500 to 1000 threads. With 300 ms of latency there isn&rsquo;t a massive spike but you certainly don&rsquo;t gain much beyond 1000 threads. As a bonus, with a fake RTT of 1s you can see the sweet spot is around 1000 threads too, however, CPU is proportionally lower to the RTT, which makes sense as you are doing the same work over a longer period of time.</p>
<h2 id="coroutines-to-the-rescue">Coroutines to the rescue</h2>
<p>At the time of writing this post <code>nornir</code> doesn&rsquo;t have support for <code>asyncio</code> (even though there has been some proposals and even some working code, if you are interested in seeing this happen reach out to me). Instead, we are going to use <code>gornir</code> to perform the same tests as before but using coroutines instead (or <code>goroutines</code> as they are called in <code>golang</code>). First the code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;context&#34;</span>
	<span style="color:#e6db74">&#34;flag&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>

	<span style="color:#e6db74">&#34;github.com/nornir-automation/gornir/pkg/gornir&#34;</span>
	<span style="color:#e6db74">&#34;github.com/nornir-automation/gornir/pkg/plugins/logger&#34;</span>
	<span style="color:#e6db74">&#34;github.com/nornir-automation/gornir/pkg/plugins/runner&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">FakeInv</span>() <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Inventory</span> {
	<span style="color:#a6e22e">hosts</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Host</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;dev%d&#34;</span>, <span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">hosts</span>[<span style="color:#a6e22e">name</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Host</span>{<span style="color:#a6e22e">Hostname</span>: <span style="color:#a6e22e">name</span>}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Inventory</span>{
		<span style="color:#a6e22e">Hosts</span>: <span style="color:#a6e22e">hosts</span>,
	}
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeRTT</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">rtt</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fakeRTT</span>) <span style="color:#a6e22e">Metadata</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">TaskMetadata</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fakeRTT</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">logger</span> <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Logger</span>, <span style="color:#a6e22e">host</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Host</span>) (<span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">TaskInstanceResult</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">rtt</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">rtt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">flag</span>.<span style="color:#a6e22e">Duration</span>(<span style="color:#e6db74">&#34;fake-rtt&#34;</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>, <span style="color:#e6db74">&#34;&#34;</span>)
	<span style="color:#a6e22e">flag</span>.<span style="color:#a6e22e">Parse</span>()

	<span style="color:#a6e22e">log</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">NewLogrus</span>(<span style="color:#66d9ef">false</span>)

	<span style="color:#a6e22e">gr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">New</span>().<span style="color:#a6e22e">WithInventory</span>(<span style="color:#a6e22e">FakeInv</span>()).<span style="color:#a6e22e">WithLogger</span>(<span style="color:#a6e22e">log</span>).<span style="color:#a6e22e">WithRunner</span>(<span style="color:#a6e22e">runner</span>.<span style="color:#a6e22e">Parallel</span>())

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gr</span>.<span style="color:#a6e22e">RunSync</span>(
		<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(),
		<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeRTT</span>{<span style="color:#a6e22e">rtt</span>: <span style="color:#f92672">*</span><span style="color:#a6e22e">rtt</span>},
	)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
	}
}
</code></pre></div><p>Before moving forward, some explanations of how multi-threading/coroutines work here:</p>
<ol>
<li>For each device <code>gornir</code> is going to create a coroutine</li>
<li>The golang runtime is going to create as many threads as <code>GOMAXPROCS</code> indicates, by default the number of cores. These threads will be used to run the scheduler, the garbage collector, each coroutine, etc&hellip;</li>
</ol>
<p>First we need to compile it:</p>
<pre><code>$ go build -o fakertt-test main.go
</code></pre><p>If you haven&rsquo;t dealt with golang before, yes, it&rsquo;s that easy :) Now let&rsquo;s run it with the default number of threads for an RTT of 50ms:</p>
<pre><code>./fakertt-test -fake-rtt 50ms  0.16s user 0.04s system 185% cpu 0.111 total
</code></pre><p>As you can see with the default number of threads (one per core) and using coroutines we managed to squeeze the CPU and execute the program in 111ms, barely more than twice the RTT we set. Let&rsquo;s see with only one thread:</p>
<pre><code>GOMAXPROCS=1 ./fakertt-test -fake-rtt 50ms  0.09s user 0.03s system 74% cpu 0.158 total
</code></pre><p>CPU is now down to 74% and the application took 158ms, not bad. Let&rsquo;s now try with 100 threads:</p>
<pre><code>GOMAXPROCS=100 ./fakertt-test -fake-rtt 50ms  0.15s user 0.12s system 187% cpu 0.139 total
</code></pre><p>Unsurprisingly, it took longer than using only one per core while consuming the same amount of CPU.</p>
<p>Let&rsquo;s do similar tests with higher latency, now with 100ms:</p>
<pre><code>./fakertt-test -fake-rtt 100ms  0.12s user 0.11s system 144% cpu 0.160 total
GOMAXPROCS=1 ./fakertt-test -fake-rtt 100ms  0.10s user 0.03s system 62% cpu 0.208 total
GOMAXPROCS=100 ./fakertt-test -fake-rtt 100ms  0.19s user 0.13s system 168% cpu 0.192 total
</code></pre><p>We got similar results, CPU went down and execution time went up proportionally to the increase in RTT. Now let&rsquo;s try with 300ms of RTT:</p>
<pre><code>./fakertt-test -fake-rtt 300ms  0.13s user 0.08s system 57% cpu 0.363 total
GOMAXPROCS=1 ./fakertt-test -fake-rtt 300ms  0.10s user 0.02s system 29% cpu 0.425 total
GOMAXPROCS=100 ./fakertt-test -fake-rtt 300ms  0.15s user 0.14s system 74% cpu 0.387 total
</code></pre><p>Which lead to similar results, and finally with 1s of RTT:</p>
<pre><code>./fakertt-test -fake-rtt 1s  0.17s user 0.05s system 19% cpu 1.071 total
GOMAXPROCS=1 ./fakertt-test -fake-rtt 1s  0.08s user 0.05s system 11% cpu 1.121 total
GOMAXPROCS=100 ./fakertt-test -fake-rtt 1s  0.14s user 0.13s system 25% cpu 1.078 total
</code></pre><p>And again, consistent results.</p>
<p>It is worth noting that, as we saw in python (although several orders of magnitude different), the relative cost of creating threads diminishes as RTT increases. This makes sense as creating a thread is orders of magnitude faster than crossing the Atlantic. It is also worth noticing how CPU utilization goes down with RTT, which makes sense as well as the same amount of work is spread across a longer period of time.</p>
<p>It is also worth noting how efficient golang with its goroutines is. In all cases the software took barely a bit longer than the RTT to complete, squeezing the CPU as much as possible.</p>
<h2 id="summary">Summary</h2>
<p>Threads are great for parallelizing work and you can certainly create more than CPU cores you have, specially for IO-bound applications, however, they are not free, they have a cost. Coroutines help immensely lowering this cost but, specially in programming languages like python, having access to coroutines isn&rsquo;t trivial.</p>
<p>This post is not trying to convince you that using a high number of threads is bad, on the contrary, it&rsquo;s trying to encourage you to understand how computers work, your workload, and the environment you are running your code on as the same workload under different circumstances (different resources available, different latency, etc) may cause our application to behave differently.</p>
]]></content>
        </item>
        
        <item>
            <title>CNaaS-NMS</title>
            <link>/2020/03/03/cnaas-nms/</link>
            <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/03/03/cnaas-nms/</guid>
            <description>Github Docs
Campus Network-as-a-Service - Network Management System. Software to automate management of a campus network (LAN). This is an open source software developed as part of SUNETs managed service.
Planned features:
 Zero-touch provisioning of switches Automation of common changes for campus LAN Automated procedure for firmware upgrades Multi-vendor support  </description>
            <content type="html"><![CDATA[<p><a href="https://github.com/SUNET/cnaas-nms">Github</a> <a href="https://cnaas-nms.readthedocs.io/en/latest/">Docs</a></p>
<p>Campus Network-as-a-Service - Network Management System. Software to automate management of a campus network (LAN). This is an open source software developed as part of SUNETs managed service.</p>
<p>Planned features:</p>
<ul>
<li>Zero-touch provisioning of switches</li>
<li>Automation of common changes for campus LAN</li>
<li>Automated procedure for firmware upgrades</li>
<li>Multi-vendor support</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Stockpiler</title>
            <link>/2020/03/03/stockpiler/</link>
            <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/03/03/stockpiler/</guid>
            <description>Gtihub
Stockpiler gathers network device configurations and stores them in a local Git repository.
Stockpiler utilizes Nornir, Netmiko, and GitPython for a fully self-contained backup solution, and has been tested to function on Linux, MacOS, and Windows.</description>
            <content type="html"><![CDATA[<p><a href="https://github.com/rackerlabs/stockpiler">Gtihub</a></p>
<p>Stockpiler gathers network device configurations and stores them in a local Git repository.</p>
<p>Stockpiler utilizes Nornir, Netmiko, and GitPython for a fully self-contained backup solution, and has been tested to function on Linux, MacOS, and Windows.</p>
]]></content>
        </item>
        
    </channel>
</rss>
