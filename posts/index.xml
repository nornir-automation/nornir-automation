<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on nornir.tech</title>
        <link>/posts/</link>
        <description>Recent content in Posts on nornir.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Nornir</copyright>
        <lastBuildDate>Mon, 19 Apr 2021 00:00:00 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>How To: Filtering Deep Dive</title>
            <link>/2021/04/19/how-to-filtering-deep-dive/</link>
            <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
            
            <guid>/2021/04/19/how-to-filtering-deep-dive/</guid>
            <description>This is a guest post by Daniel Teycheney, for more content like this and other interesting stuff you can visit the following youtube channel, github account, blog and twitter feed.
 nornir is a first-class automation framework, so if you are reading this page, you&amp;rsquo;re probably here to learn more. One of the aspects of which sets nornir apart is filtering.
A new how-to guide has been published to the official documentation, walking through a series of use-cases and examples on how to leverage the power and flexibility of nornir filtering.</description>
            <content type="html"><![CDATA[<p><em>This is a guest post by Daniel Teycheney, for more content like this and other interesting stuff you can visit the following <a href="https://www.youtube.com/channel/UCTjhvZ6rj2Hya4nszBfXoRg">youtube channel</a>, <a href="https://github.com/writememe">github account</a>, <a href="https://blog.danielteycheney.com/">blog</a> and <a href="https://twitter.com/danielteycheney">twitter feed</a>.</em></p>
<hr>
<p>nornir is a first-class automation framework, so if you are reading this page, you&rsquo;re probably here to learn more. One of the aspects of which sets nornir apart is filtering.</p>
<p>A new how-to guide has been published to the official documentation, walking through a series of use-cases and examples on how to leverage the power
and flexibility of <code>nornir filtering</code>.</p>
<p>Some of the topics covered are:</p>
<ul>
<li>Introduction into custom inventory data</li>
<li>How to store, access, view and troubleshoot custom data</li>
<li>Basic/intermediate filtering using the <code>filter</code> method</li>
<li>Advanced filtering using the <code>F</code> object</li>
<li>Advanced filtering using filter functions</li>
</ul>
<p>A sample inventory is weaved throughout the how-to guide, so that the concepts being portrayed are contextually revelant to a real world use case. Below is the
link to the how-to guide:</p>
<p><a href="https://nornir.readthedocs.io/en/latest/howto/filtering_deep_dive.html">nornir official documentation - filtering deep dive</a></p>
<h2 id="further-resources">Further resources</h2>
<p>If you&rsquo;d like to learn more, below are some links to various resources which also touch on nornir filtering:</p>
<p><a href="https://github.com/nornir-automation/nornir/discussions/647">nornir filtering cheatsheet</a><br>
<a href="https://github.com/dravetech/nornir-workshop/blob/master/notebooks/3_filtering.ipynb">nornir-workshop - jupyter notebook filtering examples</a><br>
<a href="https://github.com/dravetech/nornir-workshop/blob/master/nornir-workshop.pdf">nornir-workshop - Full Presentation</a><br>
<a href="https://github.com/writememe/nornir-filtering-demo">nornir-filtering-demo - repository</a><br>
<a href="https://www.youtube.com/watch?v=aGyLKITj4Nw">nornir-filtering-demo - Video</a></p>
]]></content>
        </item>
        
        <item>
            <title>Nornir 3 beta</title>
            <link>/2020/06/18/nornir-3-beta/</link>
            <pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/06/18/nornir-3-beta/</guid>
            <description>I am happy to announce that nornir3 is in beta for you to test. The truth is that it&amp;rsquo;s been out already for a while but at this point I am confident it&amp;rsquo;s stable enough to open it to the wider public for testing.
To install nornir beta you will need to execute the following command:
$ pip install --pre &amp;#34;nornir&amp;gt;=3.0.0b0&amp;#34; Don&amp;rsquo;t forget the --pre option as otherwise pip won&amp;rsquo;t let you install it as it&amp;rsquo;s considered a pre-release.</description>
            <content type="html"><![CDATA[<p>I am happy to announce that nornir3 is in beta for you to test. The truth is that it&rsquo;s been out already for a while but at this point I am confident it&rsquo;s stable enough to open it to the wider public for testing.</p>
<p>To install nornir beta you will need to execute the following command:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ pip install --pre <span style="color:#e6db74">&#34;nornir&gt;=3.0.0b0&#34;</span>
</code></pre></div><p>Don&rsquo;t forget the <code>--pre</code> option as otherwise <code>pip</code> won&rsquo;t let you install it as it&rsquo;s considered a pre-release.</p>
<p>There are many new features and some changes but the main change is that <code>nornir</code> won&rsquo;t ship with plugins, instead plugins will live in their own repository. This should minimize the amount of dependencies needed to deploy nornir and also allow maintainers to better maintain the plugins they are experts on :)</p>
<p>To find plugins you can visit <a href="/nornir/plugins/">the plugin repository</a> and if you want to list your own just open a PR.</p>
<p>Instructions for installing plugins is plugin specific but in most cases it will be just a matter of using pip. For instance:</p>
<pre><code>$ pip install nornir-napalm nornir-utils nornir-jinja2
</code></pre><p>Plugins&rsquo; documentation should have more info about it.</p>
<p>You can find the docs <a href="https://nornir.readthedocs.io/en/3.0.0/">here</a> and the upgrading notes <a href="https://nornir.readthedocs.io/en/3.0.0/upgrading/2_to_3.html">here</a></p>
<p>Finally, a working example using nornir3:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir_napalm.plugins.tasks <span style="color:#f92672">import</span> napalm_cli

nr <span style="color:#f92672">=</span> InitNornir(
    inventory<span style="color:#f92672">=</span>{
        <span style="color:#e6db74">&#34;plugin&#34;</span>: <span style="color:#e6db74">&#34;SimpleInventory&#34;</span>,
        <span style="color:#e6db74">&#34;options&#34;</span>: {
            <span style="color:#e6db74">&#34;host_file&#34;</span>: <span style="color:#e6db74">&#34;inventory/hosts.yaml&#34;</span>,
            <span style="color:#e6db74">&#34;group_file&#34;</span>: <span style="color:#e6db74">&#34;inventory/groups.yaml&#34;</span>,
            <span style="color:#e6db74">&#34;defaults_file&#34;</span>: <span style="color:#e6db74">&#34;inventory/defaults.yaml&#34;</span>,
        }
    },
    dry_run<span style="color:#f92672">=</span>True,
)

result <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>run(
    napalm_cli,
    commands<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;show version&#34;</span>, <span style="color:#e6db74">&#34;show interfaces&#34;</span>],
)

<span style="color:#66d9ef">print</span>(result[<span style="color:#e6db74">&#34;rtr00&#34;</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>result[<span style="color:#e6db74">&#34;show version&#34;</span>])
</code></pre></div><p>Which is pretty much what you are used to with the difference the import path for <code>napalm_cli</code> is now different and points to the plugin library.</p>
<p>Feel free to check the documentation, try it out and contact me on slack, open issues and/or PRs if you find issues or have questions.</p>
]]></content>
        </item>
        
        <item>
            <title>Tutorial: Combining Nornir with pyATS</title>
            <link>/2020/05/13/tutorial-combining-nornir-with-pyats/</link>
            <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/05/13/tutorial-combining-nornir-with-pyats/</guid>
            <description>This is a guest post by John McGovern (IPvZero), for more content like this and other interesting stuff you can visit the following youtube channel, github account, and twitter feed.
 This tutorial aims to provide a simple use-case for combining Nornir and pyATS together in order to profile your current network configurations and implement desired state - as specified in host variable definition files.
The workflow we will follow in this tutorial will be first to:</description>
            <content type="html"><![CDATA[<p><em>This is a guest post by John McGovern (IPvZero), for more content like this and other interesting stuff you can visit the following <a href="https://youtube.com/c/IPvZero">youtube channel</a>, <a href="https://github.com/IPvZero">github account</a>, and <a href="https://twitter.com/IPvZero">twitter feed</a>.</em></p>
<hr>
<p>This tutorial aims to provide a simple use-case for combining <a href="https://github.com/nornir-automation/nornir/">Nornir</a> and <a href="https://pubhub.devnetcloud.com/media/pyats/docs/getting_started/index.html">pyATS</a> together in order to profile your current network configurations and implement desired state - as specified in host variable definition files.</p>
<p>The workflow we will follow in this tutorial will be first to:</p>
<ul>
<li>Deploy OSPF desired state using Nornir</li>
<li>Immediately deploying pyATS to capture a golden image profile of this &ldquo;desired state&rdquo;</li>
</ul>
<p>After we have conducted the initial steps we will then deploy a python script (<code>Pynir.py</code>) that will:</p>
<ul>
<li>Invoke pyATS to profile the current OSPF configuration and compare it to the golden image previously captured.</li>
<li>If pyATS detects a difference – the terminal will prompt an alert signalling that OSPF in currently out of sync with desired state</li>
<li>The script will then give the user the option to rollback to desired state</li>
<li>Should the user answer <strong>No</strong> – the script ends and all current OSPF settings and Diff artefacts are left and are able to be inspected</li>
<li>Should the user answer <strong>Yes</strong> – the script invokes Nornir to first erase all OSPF configurations currently in the network, before reimplementing desired state by pulling information from host variable definition files and leveraging jinja2 templating.</li>
<li>Lastly, if the script detects that the current OSPF profile is identical to the OSPF desired state, it will generate a message informing us that all current configurations are matching our desired state.</li>
</ul>
<p>To begin, let&rsquo;s first look at the directory structure and setup:</p>
<pre><code>ipvzero@MSI:~/Nornir-Blog$ tree
.
├── Pynir.py
├── capture-golden
├── config.yaml
├── defaults.yaml
├── groups.yaml
├── host_vars
│   ├── R1.yaml
│   ├── R2.yaml
│   ├── R3.yaml
│   ├── R4.yaml
│   ├── R5.yaml
│   ├── R6.yaml
│   ├── R7.yaml
│   └── R8.yaml
├── hosts.yaml
├── nornir-ospf.py
├── nornir.log
├── templates
│   └── ospf.j2
└── testbed.yaml

2 directories, 18 files
</code></pre><p>As you can see we can our basic Nornir yaml files:</p>
<ul>
<li><code>hosts.yaml</code></li>
<li><code>groups.yaml</code></li>
<li><code>defaults.yaml</code></li>
</ul>
<p>Notice that there is also a <code>testbed.yaml</code> file to allow pyATS to connect into and profile the network. Next, you&rsquo;ll notice we also have two directories. The first one called <code>host_vars</code> which will house our OSPF host variables (note: you can use the <code>hosts.yaml</code> file instead, but I have chosen to create a separate directory to perform this task). The second is called <code>templates</code> which will house our OSPF Jinja2 template.</p>
<p>Importantly, you&rsquo;ll notice a <code>capture-golden</code> file. This is a very simple bash script used to capture our &ldquo;golden&rdquo; snapshot of our desired OSPF state. It simply executes a pyATS command. You can type this command by hand should you wish, but since the output directory has to remain the same since it will be referenced by the <code>Pynir.py</code> script – for consistency, I have elected to execute it from a bash script to prevent me mistyping the output destination. Let&rsquo;s look inside to see what&rsquo;s going on:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/bash
</span><span style="color:#75715e"></span>pyats learn ospf --testbed-file testbed.yaml --output desired-ospf
</code></pre></div><p>As you can see the bash script simply tells pyATS to learn the network&rsquo;s OSPF configurations and save the output into a directory called <code>desired-ospf</code>. This directory will act as our reference point.</p>
<p>Let&rsquo;s take a look inside the <code>host_vars</code> directory and see what our host variable definition files look like. For brevity, let&rsquo;s just look at <code>R1.yaml</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">OSPF</span>:
    <span style="color:#66d9ef">process</span>: <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">id </span>: <span style="color:#ae81ff">1.1.1.1</span>
    <span style="color:#66d9ef">networks</span>:
      - <span style="color:#66d9ef">net</span>: <span style="color:#ae81ff">192.168.1.0</span>
        <span style="color:#66d9ef">wildcard</span>: <span style="color:#ae81ff">0.0.0.255</span>
        <span style="color:#66d9ef">area</span>: <span style="color:#ae81ff">0</span>
      - <span style="color:#66d9ef">net</span>: <span style="color:#ae81ff">192.168.10.0</span>
        <span style="color:#66d9ef">wildcard</span>: <span style="color:#ae81ff">0.0.0.255</span>
        <span style="color:#66d9ef">area</span>: <span style="color:#ae81ff">0</span>
</code></pre></div><p>We have a very basic OSPF setup which lists the process ID number, the RID, and the network statement configs for the router. R2 through to R8 have very similar configurations. As this is simply a demo, I have created easily identifiable variations between files. For example, R5 uses OSPF process ID of 5, with a RID of 5.5.5.5 and the networks it advertises are &ldquo;192.168.5.0&rdquo; and &ldquo;192.168.50.0&rdquo;. These files represent our desired state. In other words, this is what our network &ldquo;should look like&rdquo;.</p>
<p>Next, let&rsquo;s look inside the templates directory and open our <code>ospf.j2</code> file:</p>
<pre><code class="language-jinja2" data-lang="jinja2">router ospf {{ host.OSPF.process }}
  router-id {{ host.OSPF.id }}
  {% for n in host.OSPF.networks %}
  network {{ n.net }} {{ n.wildcard }} area {{ n.area }}
  {% endfor %}
</code></pre><p>This template will simply reference the Keys specificed in our host_var yaml files and populate the template with their corresponding Values to build our desired OSPF configuration.</p>
<p>You will notice we have a <code>nornir-ospf.py</code> script. This is the script we will use to first initially push our desired state onto the routers. This script simply pulls desired state from our <code>host_vars</code> and pushes them through our Jinja2 template onto the network. In other words, it does not remove old stale configs (like <code>Pynir.py</code> will) so the assumption here is that we are working with a blank slate on the devices. Let&rsquo;s look inside the script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir.plugins.tasks.data <span style="color:#f92672">import</span> load_yaml
<span style="color:#f92672">from</span> nornir.plugins.tasks.text <span style="color:#f92672">import</span> template_file
<span style="color:#f92672">from</span> nornir.plugins.functions.text <span style="color:#f92672">import</span> print_result
<span style="color:#f92672">from</span> nornir.plugins.tasks.networking <span style="color:#f92672">import</span> netmiko_send_config

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">load_ospf</span>(task):
    data <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>load_yaml,file<span style="color:#f92672">=</span>f<span style="color:#e6db74">&#39;./host_vars/{task.host}.yaml&#39;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;OSPF&#34;</span>] <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>result[<span style="color:#e6db74">&#34;OSPF&#34;</span>]
    r <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>template_file, template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ospf.j2&#34;</span>, path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./templates&#34;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>] <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>result
    output <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>]
    send <span style="color:#f92672">=</span> output<span style="color:#f92672">.</span>splitlines()
    task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_config, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;IPvZero Commands&#34;</span>, config_commands<span style="color:#f92672">=</span>send)

nr <span style="color:#f92672">=</span> InitNornir()
results <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>run(load_ospf)
print_result(results)
</code></pre></div><p>This is a fairly typical script which will pull information from the desired state specified in our <code>host_vars</code> yaml files, save the information and use those values to build our configurations based on the syntax specified in our Jinja2 template. Nornir then invokes Netmiko to push those configurations out to all of our respective devices in the network. Now that we understand what&rsquo;s going on, let&rsquo;s execute that script and push our desired state onto our otherwise blank network:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/6.png?raw=true" alt="alt text"></p>
<p>With our desired state now present on the network, let&rsquo;s immediately use pyATS to build a detailed profile of that configuration and grab our &ldquo;golden&rdquo; snapshot. Let&rsquo;s execute the <code>capture-golden</code> script:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/7.png?raw=true" alt="alt text"></p>
<p>pyATS has successfully profiled our desired state and you will notice the addition of a new directory called <code>desired-ospf</code> which houses of all of our detailed OSPF information for each device.
Now that we have pushed our desired state and successfully created a snapshot for future comparison, let&rsquo;s look at the main script which we will use for our OSPF management going forward, <code>Pynir.py</code>. The script is relatively long so let&rsquo;s break it down into sections. First we begin with our imports - and I have also included a Pyfiglet banner for purely aesthetic purposes (who doesn&rsquo;t like to make their scripts pretty, right?).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> subprocess
<span style="color:#f92672">import</span> colorama
<span style="color:#f92672">from</span> colorama <span style="color:#f92672">import</span> Fore, Style
<span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir.plugins.tasks.networking <span style="color:#f92672">import</span> netmiko_send_command
<span style="color:#f92672">from</span> nornir.plugins.functions.text <span style="color:#f92672">import</span> print_result, print_title
<span style="color:#f92672">from</span> nornir.plugins.tasks.networking <span style="color:#f92672">import</span> netmiko_send_config
<span style="color:#f92672">from</span> nornir.plugins.tasks.data <span style="color:#f92672">import</span> load_yaml
<span style="color:#f92672">from</span> nornir.plugins.tasks.text <span style="color:#f92672">import</span> template_file
<span style="color:#f92672">from</span> pyfiglet <span style="color:#f92672">import</span> Figlet

nr <span style="color:#f92672">=</span> InitNornir(config_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;config.yaml&#34;</span>)
clear_command <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;clear&#34;</span>
os<span style="color:#f92672">.</span>system(clear_command)
custom_fig <span style="color:#f92672">=</span> Figlet(font<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;isometric3&#39;</span>)
<span style="color:#66d9ef">print</span>(custom_fig<span style="color:#f92672">.</span>renderText(<span style="color:#e6db74">&#39;pyNIR&#39;</span>))
</code></pre></div><p>Next, we create a custom function called <code>clean_ospf</code>. The first challenge of the script was to find a way to strip away all OSPF configurations, should that be required. The problem with automating over legacy devices with no API capabilities, however, is that we are heavily reliant on screen-scraping – an inelegant and unfortunately necessary solution. To do so, I made the decision to use Nornir to execute a <code>show run | s ospf</code> on all devices, saved the resulting output, and began screen-scraping to identify digits in the text. The aim here was to identify any OSPF process IDs which could then be extracted and used to negate the process by executing a <code>no router opsf</code>; followed by the relevant process ID. The challenge here is that the show command output would also include area ID information – and OSPFs most common area configuration is for area 0. Of course <code>router ospf 0</code> is not a legal command, so in order to avoid this I included a conditional statement that would skip over and <code>continue</code> past any number zeros in the output. The second challenge would be avoiding needless repetition. Should OSPF be configured via the interfaces, the resulting show output could, for example, have multiple: <code>ip ospf 1 area 0</code>
<code>ip ospf 1 area 0</code>.
Parsing out this information could lead to the script executing multiple <code>no router ospf 1</code>; commands which is, of course, unnecessary. To avoid this, I elected to push all output into a python list, and from there remove all duplicates. There is still, however, an inefficiency given that the show output could, for example, show a multi-area OSPF configuration all within the same process. This could result in a script seeing an <code>ip ospf 1 area 5</code> configuration and attempting to execute a superfluous <code>no router ospf 5</code>. However, given that the script has protections against repetitive execution, and that routers will have limited areas configured per device (maybe 3 different areas at most per device, if at all), I made the decision that this was an acceptable inefficiency. Like I say, there is nothing elegant about screen-scraping and sometimes a 90% solution is better than no solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clean_ospf</span>(task):
    r <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_command, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Identifying Current OSPF&#34;</span>, command_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;show run | s ospf&#34;</span>)
    output <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>result
    my_list <span style="color:#f92672">=</span> []
    num <span style="color:#f92672">=</span> [int(s) <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> output<span style="color:#f92672">.</span>split() <span style="color:#66d9ef">if</span> s<span style="color:#f92672">.</span>isdigit()]
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> num:
        <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">continue</span>
        my_list<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;no router ospf &#34;</span> <span style="color:#f92672">+</span> str(x))
    my_list <span style="color:#f92672">=</span> list(dict<span style="color:#f92672">.</span>fromkeys(my_list))
    <span style="color:#66d9ef">for</span> commands <span style="color:#f92672">in</span> my_list:
        task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_config, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Removing Current OSPF&#34;</span>, config_commands<span style="color:#f92672">=</span>commands)

    desired_ospf(task)
</code></pre></div><p>Now we have the ability to remove all current OSPF configuration, we create a custom function called <code>desired_ospf</code>. This is almost identical to the earlier script and simply builds our configuration from <code>host_vars</code> definition files and pushes them through our jinja2 OSPF template and out to the devices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">desired_ospf</span>(task):
    data <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>load_yaml, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Pulling from Definition Files&#34;</span>, file<span style="color:#f92672">=</span>f<span style="color:#e6db74">&#39;./host_vars/{task.host}.yaml&#39;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;OSPF&#34;</span>] <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>result[<span style="color:#e6db74">&#34;OSPF&#34;</span>]
    r <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>template_file, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Building Desired State&#34;</span>, template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ospf.j2&#34;</span>, path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./templates&#34;</span>)
    task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>] <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>result
    output <span style="color:#f92672">=</span> task<span style="color:#f92672">.</span>host[<span style="color:#e6db74">&#34;config&#34;</span>]
    send <span style="color:#f92672">=</span> output<span style="color:#f92672">.</span>splitlines()
    task<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>netmiko_send_config, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Implementing OSPF Desired State&#34;</span>, config_commands<span style="color:#f92672">=</span>send)
</code></pre></div><p>The next part of the script is effectively what executes first and precedes our two custom functions (with will only execute upon certain conditions). Let&rsquo;s look at it. First we use the OS and Subprocess python modules to first execute the shell command <code>pyats learn ospf --testbed-file testbed.yaml --output ospf-current</code> to relearn the current state of the network&rsquo;s OSPF configs, and then run a diff between the current configs, and our previously saved golden config – <code>pyats diff desired-ospf/ ospf-current –output ospfdiff</code>. We then read the output and search for the string <code>Diff can be found</code>. If a difference is found, we are alerted to the discrepancy and offered the choice to rollback to our desired state.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">current <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pyats learn ospf --testbed-file testbed.yaml --output ospf-current&#34;</span>
os<span style="color:#f92672">.</span>system(current)
command <span style="color:#f92672">=</span> subprocess<span style="color:#f92672">.</span>run([<span style="color:#e6db74">&#34;pyats&#34;</span>, <span style="color:#e6db74">&#34;diff&#34;</span>, <span style="color:#e6db74">&#34;desired-ospf/&#34;</span>, <span style="color:#e6db74">&#34;ospf-current&#34;</span>, <span style="color:#e6db74">&#34;--output&#34;</span>, <span style="color:#e6db74">&#34;ospfdiff&#34;</span>], stdout<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE)
stringer <span style="color:#f92672">=</span> str(command)
<span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;Diff can be found&#34;</span> <span style="color:#f92672">in</span> stringer:
    os<span style="color:#f92672">.</span>system(clear_command)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>CYAN <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;#&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">70</span>)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>RED <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;ALERT: &#34;</span> <span style="color:#f92672">+</span> Style<span style="color:#f92672">.</span>RESET_ALL <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;CURRENT OSPF CONFIGURATIONS ARE NOT IN SYNC WITH DESIRED STATE!&#34;</span>)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>CYAN <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;#&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">70</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
    answer <span style="color:#f92672">=</span> input(Fore<span style="color:#f92672">.</span>YELLOW <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;Would you like to reverse the current OSPF configuration back to its desired state? &#34;</span> <span style="color:#f92672">+</span> Style<span style="color:#f92672">.</span>RESET_ALL <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&lt;y/n&gt;: &#34;</span>
)
</code></pre></div><p>Should we answer &ldquo;y&rdquo; and affirm our decision to rollback, the script will first remove all current ospf and diff artefacts before calling our <code>clean_ospf</code> custom function, which, in turn, calls our <code>desired-ospf</code> function and prints the output.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#66d9ef">if</span> answer <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;y&#34;</span>:
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>() <span style="color:#f92672">-&gt;</span> None:
            clean_up <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rm -r ospfdiff ospf-current&#34;</span>
            os<span style="color:#f92672">.</span>system(clean_up)
            os<span style="color:#f92672">.</span>system(clear_command)
            nr <span style="color:#f92672">=</span> InitNornir(config_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;config.yaml&#34;</span>)
            output <span style="color:#f92672">=</span> nr<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>clean_ospf)
            print_title(<span style="color:#e6db74">&#34;REVERSING OSPF CONFIGURATION BACK INTO DESIRED STATE&#34;</span>)
            print_result(output)

        <span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
                main()
</code></pre></div><p>Should we choose <strong>not</strong> to rollback, however, and instead want to inspect those changes in detail - by selecting &ldquo;n&rdquo; the script simply terminates and leaves all artefacts for our inspection.</p>
<p>Lastly, should the script detect no changes between the current state of our OSPF network and the configurations in our golden capture – the script simply ends and informs us that all OSPF configurations are matching desired state:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">else</span>:
    clean_up <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rm -r ospfdiff ospf-current&#34;</span>
    os<span style="color:#f92672">.</span>system(clean_up)
    os<span style="color:#f92672">.</span>system(clear_command)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">75</span>)
    <span style="color:#66d9ef">print</span>(Fore<span style="color:#f92672">.</span>GREEN <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;Good news! OSPF configurations are matching desired state!&#34;</span> <span style="color:#f92672">+</span> Style<span style="color:#f92672">.</span>RESET_ALL)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">75</span>)

</code></pre></div><h2 id="demo---lets-break-the-network">Demo - Let&rsquo;s Break The Network!</h2>
<p>Now that we understand the logic of the script, let&rsquo;s perform a demo and see the workflow in action. Now remember, we have already deployed our initial desired state and captured that snapshot using both the <code>nornir-ospf.py</code> and <code>capture-golden</code> scripts. Let&rsquo;s first &ldquo;break&rdquo; the network by adding some unwanted OSPF configurations on R8:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/14.png?raw=true" alt="alt text"></p>
<p>Now the current state of our OSPF network does not match the configuration specified in our desired state. Let&rsquo;s run the <code>Pynir.py</code> script and see if it detects the change. <code>Pynir.py</code> first starts learning the current OSPF configurations:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/15.png?raw=true" alt="alt text"></p>
<p>The change is detected and we are both notified and given the option to rollback. This time, we first want to inspect the changes, so let&rsquo;s answer &ldquo;n&rdquo; for No:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/16.png?raw=true" alt="alt text"></p>
<p>The script terminates and leaves the relevant artefacts which we are free to inspect (notice the new directories <code>ospf-current</code> and <code>ospfdiff</code>):</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/17.png?raw=true" alt="alt text"></p>
<p>We can now freely examine these changes and decide if we want to erase them by performing a rollback, or leave them and updating our OSPF definitions:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/18.png?raw=true" alt="alt text"></p>
<p>Upon examination it is clear now that these configuration are certainly not meant to be present in the network. We then rerun Pynir, this time choosing &ldquo;y&rdquo; to rollback to our desired state:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/19.png?raw=true" alt="alt text"></p>
<p>This selection triggers Nornir to execute our custom functions that remove all current OSPF configs and artefacts before redeploying OSPF as specified in our <code>host_vars</code> definition files.</p>
<p>First the OSPF configurations are identified by the show output, and then negated:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/20.png?raw=true" alt="alt text"></p>
<p>Pynir then pulls out desired state from our host varables, builds our configuration using the Jinja2 template, and pushes out the config: <img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/21.png?raw=true" alt="alt text"></p>
<p>For our final validation, let&rsquo;s rerun the script and ensure that we are now in compliance with our desired state:</p>
<p><img src="https://github.com/IPvZero/Nornir-Blog/blob/master/images/22.png?raw=true" alt="alt text"></p>
<p>Excellent! Everything is back to the way it should be.</p>
<p>As you can see, combining Nornir with pyATS can allow us to easily monitor and rollback our network to ensure we are compliant with our desired state of the network. As demonstrated, the largest challenge was finding a workaround to remove all undesired OSPF configurations. With modern devices with APIs, with options for candidate configurations, etc, this problem vanishes. Unfortunately, however, we still need to deal with older devices that were not built with automation in mind, and we have to create inventive and sometimes inefficient workarounds to solve a particular problem. This script is an attempt at doing that.</p>
<p>You can download the script and all subsequent configurations at:
<a href="https://github.com/IPvZero/pynir">https://github.com/IPvZero/pynir</a></p>
]]></content>
        </item>
        
        <item>
            <title>how many threads are enough threads?</title>
            <link>/2020/05/01/how-many-threads-are-enough-threads/</link>
            <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/05/01/how-many-threads-are-enough-threads/</guid>
            <description>The other night there was a discussion about python multi-threading on the nornir channel on slack so I decided to do some benchmarks and explain a couple of things. I am by no means an expert on the topic, I mostly know enough to be scared about the topic and to test assumptions to avoid surprises. I am also going to try to simplify things a bit so apologies in advanced if something is slightly inaccurate.</description>
            <content type="html"><![CDATA[<p>The other night there was a discussion about python multi-threading on the nornir channel on <a href="https://networktocode.herokuapp.com/">slack</a> so I decided to do some benchmarks and explain a couple of things. I am by no means an expert on the topic, I mostly know enough to be scared about the topic and to test assumptions to avoid surprises. I am also going to try to simplify things a bit so apologies in advanced if something is slightly inaccurate. Feel free to let me know if you think something needs further explanation or clarification.</p>
<p>The first thing you need to know is what a thread is, according to the <a href="https://en.wikipedia.org/wiki/Thread_(computing)">wikipedia</a> &ldquo;a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system&rdquo;. The TL;DR; is that a thread is something you can put on a CPU core to be executed. Threads are somewhat expensive to create and manage as the OS needs to maintain several datastructures and run complex <a href="https://en.wikipedia.org/wiki/Scheduling_(computing)">algorithms</a> so an alternative to threads are <a href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a>. Coroutines offer similar functionality to OS threads but are managed by a runtime instead of by the operating system and are much more lightweight than OS threads. You probably heard about asyncio or golang&rsquo;s goroutines, those are examples of coroutine implementations.</p>
<p>Second thing you need to know is you can only run as many threads concurrently as cores you have available (twice with technologies like hyperthreading), however, computers have mechanisms to put threads in an idle state while waiting for some event to occur. For instance, if a python program runs <code>time.sleep(1)</code> it&rsquo;s going to go into this state for 1 second, during that second the program won&rsquo;t consume any CPU, and, when the time comes, the program will be woken up and resume operations. This same technique can be used when waiting for IO operations, for instance, when trying to read/write to disk or when waiting for the network to send you some information. Because those operations are several orders of magnitude slower than executing CPU instructions it is worth trying to parallelize as many of those operations as possible. If you have heard the term &ldquo;IO-bound program&rdquo;, this is a summary of what it means.</p>
<h2 id="testing-assumptions">Testing assumptions</h2>
<p>Now that we are experts on CPU design and have read all the research ever written around the topic of schedulers, let&rsquo;s design a simple test; we are going to simulate an IO-bound application by pretending we are going to connect to 10.000 devices. The application won&rsquo;t really connect to any device, instead it will just go to sleep for a given amount of time. This time we are sleeping should simulate RTT.</p>
<p>Note that this is a very simple test and doesn&rsquo;t really consume the same resources that a program connecting to real devices would consume (sockets, file descriptors, etc), resources that would add up and could cause side-effects, specially if you run the code on a shared machine. Quoting your favorite physics teacher <a href="https://xkcd.com/669/">&ldquo;this only works in the vacuum with no friction&rdquo;</a></p>
<p>Some of the things I want to see with the tests we are going to perform is:</p>
<ol>
<li>How does RTT affect the execution of the program</li>
<li>How many threads are worth creating given they are expensive to create and manage under different RTTs</li>
<li>How helpful coroutines are, are they a fad or do they solve an actual problem?</li>
</ol>
<h3 id="counting-threads-with-nornir">Counting threads with nornir</h3>
<p>To see how many is worth using when attempting to parallelize the connection to 10.000 devices using different RTTs we are going to use <code>nornir</code>. A continuation you can see the script (note it&rsquo;s using a beta version of nornir 3.0 so it might not work out of the box if you try to execute it with nornir 2.0, however, it shouldn&rsquo;t affect performance):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys
<span style="color:#f92672">import</span> time

<span style="color:#f92672">from</span> nornir <span style="color:#f92672">import</span> InitNornir
<span style="color:#f92672">from</span> nornir.core.inventory <span style="color:#f92672">import</span> Defaults, Groups, Hosts,
                                  Host, Inventory
<span style="color:#f92672">from</span> nornir.core.plugins.inventory <span style="color:#f92672">import</span> InventoryPluginRegister
<span style="color:#f92672">from</span> nornir.core.task <span style="color:#f92672">import</span> Task


NUM_DEVICES <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestInv</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Fake inventory that generates hosts dynamically
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">load</span>(self) <span style="color:#f92672">-&gt;</span> Inventory:
        hosts <span style="color:#f92672">=</span> Hosts()
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, NUM_DEVICES):
            name <span style="color:#f92672">=</span> f<span style="color:#e6db74">&#34;dev{i}&#34;</span>
            hosts[name] <span style="color:#f92672">=</span> Host(name)
        <span style="color:#66d9ef">return</span> Inventory(
          hosts<span style="color:#f92672">=</span>hosts, groups<span style="color:#f92672">=</span>Groups(), defaults<span style="color:#f92672">=</span>Defaults()
        )


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fake_task</span>(task: Task, sleep_time: float) <span style="color:#f92672">-&gt;</span> None:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    fake task that simulates RTT
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    time<span style="color:#f92672">.</span>sleep(sleep_time)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(num_workers: int, sleep_time: float) <span style="color:#f92672">-&gt;</span> None:
    InventoryPluginRegister<span style="color:#f92672">.</span>register(<span style="color:#e6db74">&#34;test-inv&#34;</span>, TestInv)

    nr <span style="color:#f92672">=</span> InitNornir(
      inventory<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;plugin&#34;</span>: <span style="color:#e6db74">&#34;test-inv&#34;</span>},
      core<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;num_workers&#34;</span>: num_workers},
    )
    nr<span style="color:#f92672">.</span>run(task<span style="color:#f92672">=</span>fake_task, sleep_time<span style="color:#f92672">=</span>sleep_time)


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
    num_workers <span style="color:#f92672">=</span> int(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>])
    sleep_time <span style="color:#f92672">=</span> float(sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">2</span>])
    main(num_workers, sleep_time)
</code></pre></div><p>Great, now let&rsquo;s see the results of running this with different parameters. First, with an RTT of 50ms:</p>
<pre><code>python script.py 100 0.05  0.78s user 0.29s system 19% cpu 5.532 total
python script.py 200 0.05  0.79s user 0.34s system 39% cpu 2.854 total
python script.py 500 0.05  0.65s user 0.37s system 73% cpu 1.389 total
python script.py 1000 0.05  0.81s user 0.37s system 118% cpu 0.995 total
python script.py 1500 0.05  0.73s user 0.48s system 125% cpu 0.969 total
python script.py 2000 0.05  0.78s user 0.47s system 125% cpu 0.993 total
python script.py 5000 0.05  0.78s user 0.47s system 126% cpu 0.987 total
python script.py 10000 0.05  0.82s user 0.37s system 123% cpu 0.962 total
</code></pre><p>Now, with an RTT of 100ms:</p>
<pre><code>python script.py 100 0.1  0.77s user 0.30s system 10% cpu 10.551 total
python script.py 200 0.1  0.75s user 0.32s system 19% cpu 5.424 total
python script.py 500 0.1  0.79s user 0.35s system 47% cpu 2.376 total
python script.py 1000 0.1  0.82s user 0.35s system 84% cpu 1.391 total
python script.py 1500 0.1  0.86s user 0.56s system 119% cpu 1.192 total
python script.py 2000 0.1  0.89s user 0.62s system 128% cpu 1.177 total
python script.py 5000 0.1  0.89s user 0.84s system 136% cpu 1.266 total
python script.py 10000 0.1  1.08s user 0.74s system 140% cpu 1.292 total
</code></pre><p>A continuation with 300ms:</p>
<pre><code>python script.py 100 0.3  0.82s user 0.24s system 3% cpu 31.016 total
python script.py 200 0.3  0.74s user 0.27s system 6% cpu 15.381 total
python script.py 500 0.3  0.75s user 0.30s system 16% cpu 6.360 total
python script.py 1000 0.3  0.73s user 0.38s system 33% cpu 3.354 total
python script.py 1500 0.3  0.82s user 0.42s system 50% cpu 2.460 total
python script.py 2000 0.3  0.94s user 0.42s system 67% cpu 2.004 total
python script.py 5000 0.3  1.15s user 1.28s system 154% cpu 1.575 total
python script.py 10000 0.3  1.14s user 1.04s system 141% cpu 1.535 total
</code></pre><p>And finally, with an RTT of 1s, just because reasons:</p>
<pre><code>python script.py 100 1  0.70s user 0.28s system 0% cpu 1:40.55 total
python script.py 200 1  0.75s user 0.19s system 1% cpu 50.445 total
python script.py 500 1  0.64s user 0.30s system 4% cpu 20.335 total
python script.py 1000 1  0.77s user 0.28s system 10% cpu 10.360 total
python script.py 1500 1  0.73s user 0.39s system 15% cpu 7.364 total
python script.py 2000 1  0.86s user 0.37s system 22% cpu 5.507 total
python script.py 5000 1  1.04s user 0.79s system 60% cpu 3.005 total
python script.py 10000 1  1.43s user 1.11s system 97% cpu 2.598 total
</code></pre><p>As you can see latency has a huge impact. If latency is low (~50ms), the cost of creating a large amount of threads is relatively high compared to the time each thread is idle so going from 200 threads to 500 threads doesn&rsquo;t gain you a lot but it increase CPU consumption by 34%. With a latency of 100ms you can see the same effect going from 500 to 1000 threads. With 300 ms of latency there isn&rsquo;t a massive spike but you certainly don&rsquo;t gain much beyond 1000 threads. As a bonus, with a fake RTT of 1s you can see the sweet spot is around 1000 threads too, however, CPU is proportionally lower to the RTT, which makes sense as you are doing the same work over a longer period of time.</p>
<h2 id="coroutines-to-the-rescue">Coroutines to the rescue</h2>
<p>At the time of writing this post <code>nornir</code> doesn&rsquo;t have support for <code>asyncio</code> (even though there has been some proposals and even some working code, if you are interested in seeing this happen reach out to me). Instead, we are going to use <code>gornir</code> to perform the same tests as before but using coroutines instead (or <code>goroutines</code> as they are called in <code>golang</code>). First the code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;context&#34;</span>
	<span style="color:#e6db74">&#34;flag&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>

	<span style="color:#e6db74">&#34;github.com/nornir-automation/gornir/pkg/gornir&#34;</span>
	<span style="color:#e6db74">&#34;github.com/nornir-automation/gornir/pkg/plugins/logger&#34;</span>
	<span style="color:#e6db74">&#34;github.com/nornir-automation/gornir/pkg/plugins/runner&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">FakeInv</span>() <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Inventory</span> {
	<span style="color:#a6e22e">hosts</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Host</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;dev%d&#34;</span>, <span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">hosts</span>[<span style="color:#a6e22e">name</span>] = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Host</span>{<span style="color:#a6e22e">Hostname</span>: <span style="color:#a6e22e">name</span>}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Inventory</span>{
		<span style="color:#a6e22e">Hosts</span>: <span style="color:#a6e22e">hosts</span>,
	}
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fakeRTT</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">rtt</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fakeRTT</span>) <span style="color:#a6e22e">Metadata</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">TaskMetadata</span> { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> }

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fakeRTT</span>) <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">logger</span> <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Logger</span>, <span style="color:#a6e22e">host</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">Host</span>) (<span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">TaskInstanceResult</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">rtt</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">rtt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">flag</span>.<span style="color:#a6e22e">Duration</span>(<span style="color:#e6db74">&#34;fake-rtt&#34;</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>, <span style="color:#e6db74">&#34;&#34;</span>)
	<span style="color:#a6e22e">flag</span>.<span style="color:#a6e22e">Parse</span>()

	<span style="color:#a6e22e">log</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">NewLogrus</span>(<span style="color:#66d9ef">false</span>)

	<span style="color:#a6e22e">gr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gornir</span>.<span style="color:#a6e22e">New</span>().<span style="color:#a6e22e">WithInventory</span>(<span style="color:#a6e22e">FakeInv</span>()).<span style="color:#a6e22e">WithLogger</span>(<span style="color:#a6e22e">log</span>).<span style="color:#a6e22e">WithRunner</span>(<span style="color:#a6e22e">runner</span>.<span style="color:#a6e22e">Parallel</span>())

	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gr</span>.<span style="color:#a6e22e">RunSync</span>(
		<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(),
		<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fakeRTT</span>{<span style="color:#a6e22e">rtt</span>: <span style="color:#f92672">*</span><span style="color:#a6e22e">rtt</span>},
	)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
	}
}
</code></pre></div><p>Before moving forward, some explanations of how multi-threading/coroutines work here:</p>
<ol>
<li>For each device <code>gornir</code> is going to create a coroutine</li>
<li>The golang runtime is going to create as many threads as <code>GOMAXPROCS</code> indicates, by default the number of cores. These threads will be used to run the scheduler, the garbage collector, each coroutine, etc&hellip;</li>
</ol>
<p>First we need to compile it:</p>
<pre><code>$ go build -o fakertt-test main.go
</code></pre><p>If you haven&rsquo;t dealt with golang before, yes, it&rsquo;s that easy :) Now let&rsquo;s run it with the default number of threads for an RTT of 50ms:</p>
<pre><code>./fakertt-test -fake-rtt 50ms  0.16s user 0.04s system 185% cpu 0.111 total
</code></pre><p>As you can see with the default number of threads (one per core) and using coroutines we managed to squeeze the CPU and execute the program in 111ms, barely more than twice the RTT we set. Let&rsquo;s see with only one thread:</p>
<pre><code>GOMAXPROCS=1 ./fakertt-test -fake-rtt 50ms  0.09s user 0.03s system 74% cpu 0.158 total
</code></pre><p>CPU is now down to 74% and the application took 158ms, not bad. Let&rsquo;s now try with 100 threads:</p>
<pre><code>GOMAXPROCS=100 ./fakertt-test -fake-rtt 50ms  0.15s user 0.12s system 187% cpu 0.139 total
</code></pre><p>Unsurprisingly, it took longer than using only one per core while consuming the same amount of CPU.</p>
<p>Let&rsquo;s do similar tests with higher latency, now with 100ms:</p>
<pre><code>./fakertt-test -fake-rtt 100ms  0.12s user 0.11s system 144% cpu 0.160 total
GOMAXPROCS=1 ./fakertt-test -fake-rtt 100ms  0.10s user 0.03s system 62% cpu 0.208 total
GOMAXPROCS=100 ./fakertt-test -fake-rtt 100ms  0.19s user 0.13s system 168% cpu 0.192 total
</code></pre><p>We got similar results, CPU went down and execution time went up proportionally to the increase in RTT. Now let&rsquo;s try with 300ms of RTT:</p>
<pre><code>./fakertt-test -fake-rtt 300ms  0.13s user 0.08s system 57% cpu 0.363 total
GOMAXPROCS=1 ./fakertt-test -fake-rtt 300ms  0.10s user 0.02s system 29% cpu 0.425 total
GOMAXPROCS=100 ./fakertt-test -fake-rtt 300ms  0.15s user 0.14s system 74% cpu 0.387 total
</code></pre><p>Which lead to similar results, and finally with 1s of RTT:</p>
<pre><code>./fakertt-test -fake-rtt 1s  0.17s user 0.05s system 19% cpu 1.071 total
GOMAXPROCS=1 ./fakertt-test -fake-rtt 1s  0.08s user 0.05s system 11% cpu 1.121 total
GOMAXPROCS=100 ./fakertt-test -fake-rtt 1s  0.14s user 0.13s system 25% cpu 1.078 total
</code></pre><p>And again, consistent results.</p>
<p>It is worth noting that, as we saw in python (although several orders of magnitude different), the relative cost of creating threads diminishes as RTT increases. This makes sense as creating a thread is orders of magnitude faster than crossing the Atlantic. It is also worth noticing how CPU utilization goes down with RTT, which makes sense as well as the same amount of work is spread across a longer period of time.</p>
<p>It is also worth noting how efficient golang with its goroutines is. In all cases the software took barely a bit longer than the RTT to complete, squeezing the CPU as much as possible.</p>
<h2 id="summary">Summary</h2>
<p>Threads are great for parallelizing work and you can certainly create more than CPU cores you have, specially for IO-bound applications, however, they are not free, they have a cost. Coroutines help immensely lowering this cost but, specially in programming languages like python, having access to coroutines isn&rsquo;t trivial.</p>
<p>This post is not trying to convince you that using a high number of threads is bad, on the contrary, it&rsquo;s trying to encourage you to understand how computers work, your workload, and the environment you are running your code on as the same workload under different circumstances (different resources available, different latency, etc) may cause our application to behave differently.</p>
]]></content>
        </item>
        
        <item>
            <title>CNaaS-NMS</title>
            <link>/2020/03/03/cnaas-nms/</link>
            <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/03/03/cnaas-nms/</guid>
            <description>Github Docs
Campus Network-as-a-Service - Network Management System. Software to automate management of a campus network (LAN). This is an open source software developed as part of SUNETs managed service.
Planned features:
 Zero-touch provisioning of switches Automation of common changes for campus LAN Automated procedure for firmware upgrades Multi-vendor support  </description>
            <content type="html"><![CDATA[<p><a href="https://github.com/SUNET/cnaas-nms">Github</a> <a href="https://cnaas-nms.readthedocs.io/en/latest/">Docs</a></p>
<p>Campus Network-as-a-Service - Network Management System. Software to automate management of a campus network (LAN). This is an open source software developed as part of SUNETs managed service.</p>
<p>Planned features:</p>
<ul>
<li>Zero-touch provisioning of switches</li>
<li>Automation of common changes for campus LAN</li>
<li>Automated procedure for firmware upgrades</li>
<li>Multi-vendor support</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Stockpiler</title>
            <link>/2020/03/03/stockpiler/</link>
            <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>/2020/03/03/stockpiler/</guid>
            <description>Gtihub
Stockpiler gathers network device configurations and stores them in a local Git repository.
Stockpiler utilizes Nornir, Netmiko, and GitPython for a fully self-contained backup solution, and has been tested to function on Linux, MacOS, and Windows.</description>
            <content type="html"><![CDATA[<p><a href="https://github.com/rackerlabs/stockpiler">Gtihub</a></p>
<p>Stockpiler gathers network device configurations and stores them in a local Git repository.</p>
<p>Stockpiler utilizes Nornir, Netmiko, and GitPython for a fully self-contained backup solution, and has been tested to function on Linux, MacOS, and Windows.</p>
]]></content>
        </item>
        
    </channel>
</rss>
